diff -ruN /home/meticulus/native/.git/HEAD /media/Exhibit/s1-4.1/frameworks/native/.git/HEAD
--- /home/meticulus/native/.git/HEAD	2014-10-06 12:29:18.099839928 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/.git/HEAD	2014-01-07 19:45:46.000000000 -0600
@@ -1 +1 @@
-f455c9a267332960334794428c2abc5f716ee6ea
+7830f8a526b1786ce058bf39cb925b11c02f84b9
Binary files /home/meticulus/native/.git/index and /media/Exhibit/s1-4.1/frameworks/native/.git/index differ
diff -ruN /home/meticulus/native/include/gui/ISurfaceComposer.h /media/Exhibit/s1-4.1/frameworks/native/include/gui/ISurfaceComposer.h
--- /home/meticulus/native/include/gui/ISurfaceComposer.h	2014-10-06 12:29:17.983839924 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/include/gui/ISurfaceComposer.h	2014-01-07 19:45:47.000000000 -0600
@@ -96,6 +96,26 @@
         eElectronBeamAnimationOff = 0x10
     };
 
+    // flags for HDMI Modes
+    enum {
+        /* No output to the external device.
+         */
+        eHDMIModeOff                    = 0,
+        /* Clones all content displayed on the lcd
+         * to the external device that is passed to gralloc and
+         * in the case of overlay (Video and Camera)
+         */
+        eHDMIModeClone                  = 1,
+        /* Clones all content displayed on the lcd
+         * to the external device that is passed to gralloc
+         */
+        eHDMIModeCloneUIOnly            = 2,
+        /* Clones the content passed to the overlay to an
+         * external device.
+         */
+        eHDMIModeCloneOverlayOnly       = 3,
+    };
+
     /* create connection with surface flinger, requires
      * ACCESS_SURFACE_FLINGER permission
      */
@@ -139,6 +159,8 @@
 
     /* return an IDisplayEventConnection */
     virtual sp<IDisplayEventConnection> createDisplayEventConnection() = 0;
+
+    virtual status_t setHDMIOutputMode(uint32_t mode) = 0;
 };
 
 // ----------------------------------------------------------------------------
@@ -160,6 +182,7 @@
         TURN_ELECTRON_BEAM_ON,
         AUTHENTICATE_SURFACE,
         CREATE_DISPLAY_EVENT_CONNECTION,
+        SET_HDMI_OUTPUT_MODE,
     };
 
     virtual status_t    onTransact( uint32_t code,
diff -ruN /home/meticulus/native/include/gui/SurfaceComposerClient.h /media/Exhibit/s1-4.1/frameworks/native/include/gui/SurfaceComposerClient.h
--- /home/meticulus/native/include/gui/SurfaceComposerClient.h	2014-10-06 12:29:17.987839924 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/include/gui/SurfaceComposerClient.h	2014-01-07 19:45:47.000000000 -0600
@@ -114,6 +114,8 @@
 
     status_t linkToComposerDeath(const sp<IBinder::DeathRecipient>& recipient,
             void* cookie = NULL, uint32_t flags = 0);
+    // Set how to handle the external device output cases
+    static status_t setHDMIOutputMode(uint32_t mode = 0);
 
     status_t    hide(SurfaceID id);
     status_t    show(SurfaceID id, int32_t layer = -1);
diff -ruN /home/meticulus/native/include/gui/SurfaceTexture.h /media/Exhibit/s1-4.1/frameworks/native/include/gui/SurfaceTexture.h
--- /home/meticulus/native/include/gui/SurfaceTexture.h	2014-10-06 12:29:17.987839924 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/include/gui/SurfaceTexture.h	2014-01-07 19:45:47.000000000 -0600
@@ -31,17 +31,22 @@
 #include <utils/Vector.h>
 #include <utils/threads.h>
 
+#include <hardware/copybit.h>
+
 #define ANDROID_GRAPHICS_SURFACETEXTURE_JNI_ID "mSurfaceTexture"
 
 namespace android {
 // ----------------------------------------------------------------------------
 
 
+class IGraphicBufferAlloc;
 class String8;
 
 class SurfaceTexture : public virtual RefBase,
         protected BufferQueue::ConsumerListener {
 public:
+    enum { NUM_BLIT_BUFFER_SLOTS = 2 };
+
     struct FrameAvailableListener : public virtual RefBase {
         // onFrameAvailable() is called each time an additional frame becomes
         // available for consumption. This means that frames that are queued
@@ -91,6 +96,16 @@
     // target texture belongs is bound to the calling thread.
     status_t updateTexImage();
 
+    // A surface that uses a non-native format requires conversion of
+    // its buffers. This conversion can be deferred until the layer
+    // based on this surface is drawn.
+    status_t updateTexImage(bool deferConversion);
+
+    // convert() performs the deferred texture conversion as scheduled
+    // by updateTexImage(bool deferConversion).
+    // The method returns immediately if no conversion is necessary.
+    status_t convert();
+
     // setBufferCountServer set the buffer count. If the client has requested
     // a buffer count using setBufferCount, the server-buffer count will
     // take effect once the client sets the count back to zero.
@@ -248,12 +263,18 @@
         virtual ~BufferRejecter() { }
     };
     friend class Layer;
-    status_t updateTexImage(BufferRejecter* rejecter);
+    status_t updateTexImage(BufferRejecter* rejecter, bool deferConversion);
 
     // createImage creates a new EGLImage from a GraphicBuffer.
     EGLImageKHR createImage(EGLDisplay dpy,
             const sp<GraphicBuffer>& graphicBuffer);
 
+    // returns TRUE if buffer needs color format conversion
+    bool conversionIsNeeded(const sp<GraphicBuffer>& graphicBuffer);
+
+    // converts buffer to a suitable color format
+    status_t convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf);
+
     // freeBufferLocked frees up the given buffer slot.  If the slot has been
     // initialized this will release the reference to the GraphicBuffer in that
     // slot and destroy the EGLImage in that slot.  Otherwise it has no effect.
@@ -316,6 +337,10 @@
     // and can be changed with a call to attachToContext.
     GLuint mTexName;
 
+    // mGraphicBufferAlloc is the connection to SurfaceFlinger that is used to
+    // allocate new GraphicBuffer objects.
+    sp<IGraphicBufferAlloc> mGraphicBufferAlloc;
+
     // mUseFenceSync indicates whether creation of the EGL_KHR_fence_sync
     // extension should be used to prevent buffers from being dequeued before
     // it's safe for them to be written. It gets set at construction time and
@@ -344,6 +369,9 @@
         // mEglImage is the EGLImage created from mGraphicBuffer.
         EGLImageKHR mEglImage;
 
+        // mEglDisplay is the EGLDisplay used to create mEglImage.
+        EGLDisplay mEglDisplay;
+
         // mFence is the EGL sync object that must signal before the buffer
         // associated with this buffer slot may be dequeued. It is initialized
         // to EGL_NO_SYNC_KHR when the buffer is created and (optionally, based
@@ -412,6 +440,38 @@
     // variables of SurfaceTexture objects. It must be locked whenever the
     // member variables are accessed.
     mutable Mutex mMutex;
+
+    // mBlitEngine is the handle to the copybit device which will be used in
+    // case color transform is needed before the EGL image is created.
+    copybit_device_t* mBlitEngine;
+
+    // mBlitSlots contains several buffers which will
+    // be rendered alternately in case color transform is needed (instead
+    // of rendering the buffers in mSlots).
+    EGLSlot mBlitSlots[NUM_BLIT_BUFFER_SLOTS];
+
+    // mNextBlitSlot is the index of the blitter buffer (in mBlitSlots) which
+    // will be used in the next color transform.
+    int mNextBlitSlot;
+
+    // mConversionSrcSlot designates the slot where source buffer
+    // for the last deferred updateTexImage is located.
+    int mConversionSrcSlot;
+
+    // mConversionBltSlot designates the slot where destination buffer
+    // for the last deferred updateTexImage is located.
+    int mConversionBltSlot;
+
+    // mNeedsConversion indicates that a format conversion is necessary
+    // before the layer based on this surface is drawn.
+    // This flag is set whenever updateTexImage() with deferred conversion
+    // is called. It is cleared once the layer is drawn,
+    // or when updateTexImage() w/o deferred conversion is called.
+    bool mNeedsConversion;
+
+    // mConvertPending indicates that the the object is in a deferred
+    // state and mNeedsConversion is true.
+    bool mConvertPending;
 };
 
 // ----------------------------------------------------------------------------
diff -ruN /home/meticulus/native/include/media/openmax/OMX_Audio.h /media/Exhibit/s1-4.1/frameworks/native/include/media/openmax/OMX_Audio.h
--- /home/meticulus/native/include/media/openmax/OMX_Audio.h	2014-10-06 11:39:35.799727803 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/include/media/openmax/OMX_Audio.h	2014-01-07 19:45:47.000000000 -0600
@@ -394,6 +394,36 @@
     OMX_U32 nSuperBlockAlign; /**< WMA Type-specific data */
 } OMX_AUDIO_PARAM_WMATYPE;
 
+
+/** WMA Pro Profile */
+typedef enum OMX_AUDIO_WMAPROPROFILETYPE {
+  OMX_AUDIO_WMAPROProfileUnused = 0,          /**< WMA unused / unknown */
+  OMX_AUDIO_WMAPROProfileM0,
+  OMX_AUDIO_WMAPROProfileM1,
+  OMX_AUDIO_WMAPROProfileM2,
+  OMX_AUDIO_WMAPROProfileM3,
+  OMX_AUDIO_WMAPROProfileMax = 0x7FFFFFFF
+} OMX_AUDIO_WMAPROPROFILETYPE;
+
+
+/** WMA Pro params */
+typedef struct OMX_AUDIO_PARAM_WMAPROTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U16 nChannels;
+    OMX_U32 nBitRate;
+    OMX_AUDIO_WMAPROPROFILETYPE eProfile;
+    OMX_U32 nSamplingRate;
+    OMX_U32 nBlockAlign;
+    OMX_U32 nSuperBlockAlign;
+    OMX_U32 nEncodeOptions;
+    OMX_U32 nAdvancedEncodeOptions;
+    OMX_U32 nAdvancedEncodeOptions2;
+    OMX_U32 nChannelMask;
+    OMX_U32 nSourceBitsPerSample;
+} OMX_AUDIO_PARAM_WMAPROTYPE;
+
 /** 
  * RealAudio format
  */
diff -ruN /home/meticulus/native/include/media/openmax/OMX_Index.h /media/Exhibit/s1-4.1/frameworks/native/include/media/openmax/OMX_Index.h
--- /home/meticulus/native/include/media/openmax/OMX_Index.h	2014-10-06 11:39:35.803727804 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/include/media/openmax/OMX_Index.h	2014-01-07 19:45:47.000000000 -0600
@@ -263,6 +263,7 @@
        to 0x7FFFFFFE.  This range is not broken out by vendor, so
        private indexes are not guaranteed unique and therefore should
        only be sent to the appropriate component. */
+    OMX_IndexParamAudioWMAPro = 0x7F001012,
 
     OMX_IndexMax = 0x7FFFFFFF
 
diff -ruN /home/meticulus/native/include/media/openmax/OMX_IVCommon.h /media/Exhibit/s1-4.1/frameworks/native/include/media/openmax/OMX_IVCommon.h
--- /home/meticulus/native/include/media/openmax/OMX_IVCommon.h	2014-10-06 12:29:17.987839924 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/include/media/openmax/OMX_IVCommon.h	2014-01-07 19:45:47.000000000 -0600
@@ -159,6 +159,7 @@
     OMX_COLOR_FormatAndroidOpaque = 0x7F000789,
     OMX_TI_COLOR_FormatYUV420PackedSemiPlanar = 0x7F000100,
     OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00,
+    OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB = 0x7FA00000,
     OMX_COLOR_FormatMax = 0x7FFFFFFF
 } OMX_COLOR_FORMATTYPE;
 
diff -ruN /home/meticulus/native/include/ui/FramebufferNativeWindow.h /media/Exhibit/s1-4.1/frameworks/native/include/ui/FramebufferNativeWindow.h
--- /home/meticulus/native/include/ui/FramebufferNativeWindow.h	2014-10-06 12:29:17.991839924 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/include/ui/FramebufferNativeWindow.h	2014-01-07 19:45:47.000000000 -0600
@@ -28,7 +28,9 @@
 #include <ui/ANativeObjectBase.h>
 #include <ui/Rect.h>
 
+#ifndef NUM_FRAME_BUFFERS
 #define NUM_FRAME_BUFFERS  2
+#endif
 
 extern "C" EGLNativeWindowType android_createDisplaySurface(void);
 
@@ -56,7 +58,13 @@
     status_t setUpdateRectangle(const Rect& updateRect);
     status_t compositionComplete();
 
+    status_t rotate(unsigned int absoluteDegree);
+
+    void discardQueuedBuffers(bool on);
+
     void dump(String8& result);
+    void UIRotationChange(int uiRotation);
+    void enableHDMIMirroring(bool enable);
 
     // for debugging only
     int getCurrentBufferIndex() const;
@@ -70,7 +78,8 @@
     static int queueBuffer(ANativeWindow* window, ANativeWindowBuffer* buffer);
     static int query(const ANativeWindow* window, int what, int* value);
     static int perform(ANativeWindow* window, int operation, ...);
-    
+    static int cancelBuffer(ANativeWindow* window, android_native_buffer_t* buffer);
+
     framebuffer_device_t* fbDev;
     alloc_device_t* grDev;
 
@@ -84,8 +93,9 @@
     int32_t mBufferHead;
     int32_t mCurrentBufferIndex;
     bool mUpdateOnDemand;
+    int mDiscardQueuedBuffersCnt;
 };
-    
+
 // ---------------------------------------------------------------------------
 }; // namespace android
 // ---------------------------------------------------------------------------
diff -ruN /home/meticulus/native/include/ui/PixelFormat.h /media/Exhibit/s1-4.1/frameworks/native/include/ui/PixelFormat.h
--- /home/meticulus/native/include/ui/PixelFormat.h	2014-10-06 12:29:17.995839924 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/include/ui/PixelFormat.h	2014-01-07 19:45:47.000000000 -0600
@@ -64,6 +64,13 @@
     PIXEL_FORMAT_RGBA_5551   = HAL_PIXEL_FORMAT_RGBA_5551,  // 16-bit ARGB
     PIXEL_FORMAT_RGBA_4444   = HAL_PIXEL_FORMAT_RGBA_4444,  // 16-bit ARGB
     PIXEL_FORMAT_A_8         = 8,                           // 8-bit A
+
+    // Added Support for YUV42XMBN,
+    // Required for Copybit CC acceleration
+    PIXEL_FORMAT_YCBCR42XMBN = HAL_PIXEL_FORMAT_YCBCR42XMBN,
+    PIXEL_FORMAT_YCbCr_420_SP = HAL_PIXEL_FORMAT_YCbCr_420_SP,
+    PIXEL_FORMAT_YCbCr_420_P = HAL_PIXEL_FORMAT_YCbCr_420_P,
+    PIXEL_FORMAT_YCbCr_422_I = HAL_PIXEL_FORMAT_YCbCr_422_I,
 };
 
 typedef int32_t PixelFormat;
diff -ruN /home/meticulus/native/include/ui/Region.h /media/Exhibit/s1-4.1/frameworks/native/include/ui/Region.h
--- /home/meticulus/native/include/ui/Region.h	2014-10-06 12:29:17.999839924 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/include/ui/Region.h	2014-01-07 19:45:47.000000000 -0600
@@ -24,6 +24,8 @@
 
 #include <ui/Rect.h>
 
+#include <hardware/copybit.h>
+
 namespace android {
 // ---------------------------------------------------------------------------
 
@@ -195,6 +197,27 @@
 Region& Region::operator += (const Point& pt) {
     return translateSelf(pt.x, pt.y);
 }
+
+// ---------------------------------------------------------------------
+
+struct region_iterator : public copybit_region_t {
+    region_iterator(const Region& region)
+        : b(region.begin()), e(region.end()) {
+        this->next = iterate;
+    }
+private:
+    static int iterate(copybit_region_t const * self, copybit_rect_t* rect) {
+        region_iterator const* me = static_cast<region_iterator const*>(self);
+        if (me->b != me->e) {
+            *reinterpret_cast<Rect*>(rect) = *me->b++;
+            return 1;
+        }
+        return 0;
+    }
+    mutable Region::const_iterator b;
+    Region::const_iterator const e;
+};
+
 // ---------------------------------------------------------------------------
 }; // namespace android
 
diff -ruN /home/meticulus/native/libs/gui/ISurfaceComposer.cpp /media/Exhibit/s1-4.1/frameworks/native/libs/gui/ISurfaceComposer.cpp
--- /home/meticulus/native/libs/gui/ISurfaceComposer.cpp	2014-10-06 12:29:18.011839925 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/libs/gui/ISurfaceComposer.cpp	2014-01-07 19:45:46.000000000 -0600
@@ -99,6 +99,15 @@
         remote()->transact(BnSurfaceComposer::BOOT_FINISHED, data, &reply);
     }
 
+    virtual status_t setHDMIOutputMode(uint32_t mode)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
+        data.writeInt32(mode);
+        remote()->transact(BnSurfaceComposer::SET_HDMI_OUTPUT_MODE, data, &reply);
+        return reply.readInt32();
+    }
+
     virtual status_t captureScreen(DisplayID dpy,
             sp<IMemoryHeap>* heap,
             uint32_t* width, uint32_t* height, PixelFormat* format,
@@ -236,6 +245,11 @@
             sp<IBinder> b = getCblk()->asBinder();
             reply->writeStrongBinder(b);
         } break;
+        case SET_HDMI_OUTPUT_MODE: {
+            CHECK_INTERFACE(ISurfaceComposer, data, reply);
+            int32_t mode = data.readInt32();
+            reply->writeInt32( setHDMIOutputMode(mode) );
+        } break;
         case CAPTURE_SCREEN: {
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             DisplayID dpy = data.readInt32();
diff -ruN /home/meticulus/native/libs/gui/SurfaceComposerClient.cpp /media/Exhibit/s1-4.1/frameworks/native/libs/gui/SurfaceComposerClient.cpp
--- /home/meticulus/native/libs/gui/SurfaceComposerClient.cpp	2014-10-06 12:29:18.019839925 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/libs/gui/SurfaceComposerClient.cpp	2014-01-07 19:45:46.000000000 -0600
@@ -419,6 +419,12 @@
     return getComposer().setFreezeTint(this, id, tint);
 }
 
+status_t SurfaceComposerClient::setHDMIOutputMode(uint32_t mode)
+{
+    sp<ISurfaceComposer> sm(getComposerService());
+    return sm->setHDMIOutputMode(mode);
+}
+
 status_t SurfaceComposerClient::setPosition(SurfaceID id, float x, float y) {
     return getComposer().setPosition(this, id, x, y);
 }
diff -ruN /home/meticulus/native/libs/gui/SurfaceTexture.cpp /media/Exhibit/s1-4.1/frameworks/native/libs/gui/SurfaceTexture.cpp
--- /home/meticulus/native/libs/gui/SurfaceTexture.cpp	2014-10-06 12:29:18.019839925 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/libs/gui/SurfaceTexture.cpp	2014-01-07 19:45:46.000000000 -0600
@@ -27,6 +27,7 @@
 #include <GLES2/gl2ext.h>
 
 #include <hardware/hardware.h>
+#include <ui/PixelFormat.h>
 
 #include <gui/IGraphicBufferAlloc.h>
 #include <gui/ISurfaceComposer.h>
@@ -119,12 +120,17 @@
     mEglDisplay(EGL_NO_DISPLAY),
     mEglContext(EGL_NO_CONTEXT),
     mAbandoned(false),
+    mNextBlitSlot(0),
+    mNeedsConversion(false),
+    mConvertPending(false),
     mCurrentTexture(BufferQueue::INVALID_BUFFER_SLOT),
     mAttached(true)
 {
     // Choose a name using the PID and a process-unique ID.
     mName = String8::format("unnamed-%d-%d", getpid(), createProcessUniqueId());
     ST_LOGV("SurfaceTexture");
+    sp<ISurfaceComposer> composer(ComposerService::getComposerService());
+    mGraphicBufferAlloc = composer->createGraphicBufferAlloc();
     if (bufferQueue == 0) {
         ST_LOGV("Creating a new BufferQueue");
         mBufferQueue = new BufferQueue(allowSynchronousMode);
@@ -153,12 +159,28 @@
         mBufferQueue->setConsumerName(mName);
         mBufferQueue->setConsumerUsageBits(DEFAULT_USAGE_FLAGS);
     }
+
+    for (int i = 0; i < NUM_BLIT_BUFFER_SLOTS; i++) {
+        mBlitSlots[i].mEglImage = EGL_NO_IMAGE_KHR;
+        mBlitSlots[i].mEglDisplay = EGL_NO_DISPLAY;
+    }
+
+    hw_module_t const* module;
+    mBlitEngine = 0;
+    if (hw_get_module(COPYBIT_HARDWARE_MODULE_ID, &module) == 0) {
+        copybit_open(module, &mBlitEngine);
+    }
+    ALOGE_IF(!mBlitEngine, "\nCannot open copybit mBlitEngine=%p", mBlitEngine);
 }
 
 SurfaceTexture::~SurfaceTexture() {
     ST_LOGV("~SurfaceTexture");
 
     abandon();
+
+    if (mBlitEngine) {
+        copybit_close(mBlitEngine);
+    }
 }
 
 status_t SurfaceTexture::setBufferCountServer(int bufferCount) {
@@ -176,10 +198,15 @@
 }
 
 status_t SurfaceTexture::updateTexImage() {
-    return SurfaceTexture::updateTexImage(NULL);
+    return SurfaceTexture::updateTexImage(NULL, false);
+}
+
+status_t SurfaceTexture::updateTexImage(bool deferConversion) {
+    return SurfaceTexture::updateTexImage(NULL, deferConversion);
 }
 
-status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter) {
+#define STE_DEFERDBG 0
+status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool deferConversion) {
     ATRACE_CALL();
     ST_LOGV("updateTexImage");
     Mutex::Autolock lock(mMutex);
@@ -245,18 +272,100 @@
         // Update the GL texture object. We may have to do this even when
         // item.mGraphicBuffer == NULL, if we destroyed the EGLImage when
         // detaching from a context but the buffer has not been re-allocated.
-        EGLImageKHR image = mEGLSlots[buf].mEglImage;
-        if (image == EGL_NO_IMAGE_KHR) {
-            if (mEGLSlots[buf].mGraphicBuffer == NULL) {
-                ST_LOGE("updateTexImage: buffer at slot %d is null", buf);
-                err = BAD_VALUE;
+        EGLImageKHR image;
+        sp<GraphicBuffer> graphicBuffer;
+        mConvertPending = false;
+        if (conversionIsNeeded(mEGLSlots[buf].mGraphicBuffer)) {
+            mNeedsConversion = deferConversion;
+            // If color conversion is needed we can't use the graphic buffers
+            // located in mSlots for the textures (wrong color format). Instead
+            // color convert it into a buffer in mBlitSlots and use that instead.
+            image = mBlitSlots[mNextBlitSlot].mEglImage;
+
+            // If there exists an image already, make sure that
+            // the dimensions match the current source buffer.
+            // Otherwise, destroy the buffer and let a new one be allocated.
+            if (image != EGL_NO_IMAGE_KHR &&
+                    mEGLSlots[buf].mGraphicBuffer != NULL &&
+                    mBlitSlots[mNextBlitSlot].mGraphicBuffer != NULL) {
+                sp<GraphicBuffer> &srcBuf = mEGLSlots[buf].mGraphicBuffer;
+                sp<GraphicBuffer> &bltBuf =
+                    mBlitSlots[mNextBlitSlot].mGraphicBuffer;
+                if (srcBuf->getWidth() != bltBuf->getWidth() ||
+                        srcBuf->getHeight() != bltBuf->getHeight()) {
+                    eglDestroyImageKHR(mBlitSlots[mNextBlitSlot].mEglDisplay,
+                        image);
+                    mBlitSlots[mNextBlitSlot].mEglImage = EGL_NO_IMAGE_KHR;
+                    mBlitSlots[mNextBlitSlot].mGraphicBuffer = NULL;
+                    image = EGL_NO_IMAGE_KHR;
+                }
+            }
+
+            if (image == EGL_NO_IMAGE_KHR) {
+                sp<GraphicBuffer> &srcBuf = mEGLSlots[buf].mGraphicBuffer;
+                status_t res = 0;
+
+                sp<GraphicBuffer> blitBuffer(
+                        mGraphicBufferAlloc->createGraphicBuffer(
+                                srcBuf->getWidth(), srcBuf->getHeight(),
+                                PIXEL_FORMAT_RGBA_8888, srcBuf->getUsage(),
+                                &res));
+                if (blitBuffer == 0) {
+                    ST_LOGE("updateTexImage: SurfaceComposer::createGraphicBuffer failed");
+                    return NO_MEMORY;
+                }
+                if (res != NO_ERROR) {
+                    ST_LOGW("updateTexImage: SurfaceComposer::createGraphicBuffer error=%#04x", res);
+                }
+                mBlitSlots[mNextBlitSlot].mGraphicBuffer = blitBuffer;
+
+                image = createImage(dpy, blitBuffer);
+                mBlitSlots[mNextBlitSlot].mEglImage = image;
+                mBlitSlots[mNextBlitSlot].mEglDisplay = dpy;
+            }
+
+            if (deferConversion) {
+                mConversionSrcSlot = buf;
+                mConversionBltSlot = mNextBlitSlot;
+                graphicBuffer = mEGLSlots[buf].mGraphicBuffer;
+                mConvertPending = true;
+                // At this point graphicBuffer and image do not point
+                // at matching buffers. This is intentional as this
+                // surface might end up being taken care of by HWComposer,
+                // which needs access to the original buffer.
+                // GL however, is fed an EGLImage that is created from
+                // a conversion buffer. It will have its
+                // content updated once the surface is actually drawn
+                // in Layer::onDraw()
             } else {
-                image = createImage(dpy, mEGLSlots[buf].mGraphicBuffer);
-                mEGLSlots[buf].mEglImage = image;
-                if (image == EGL_NO_IMAGE_KHR) {
-                    // NOTE: if dpy was invalid, createImage() is guaranteed to
-                    // fail. so we'd end up here.
-                    err = UNKNOWN_ERROR;
+                if (convert(mEGLSlots[buf].mGraphicBuffer,
+                        mBlitSlots[mNextBlitSlot].mGraphicBuffer) != OK) {
+                    ALOGE("updateTexImage: convert failed");
+                    return UNKNOWN_ERROR;
+                }
+                graphicBuffer = mBlitSlots[mNextBlitSlot].mGraphicBuffer;
+            }
+
+            // mBlitSlots contains several buffers (NUM_BLIT_BUFFER_SLOTS),
+            // advance (potentially wrap) the index
+            mNextBlitSlot = (mNextBlitSlot + 1) % NUM_BLIT_BUFFER_SLOTS;
+        } else {
+            mNeedsConversion = false;
+            image = mEGLSlots[buf].mEglImage;
+            graphicBuffer = mEGLSlots[buf].mGraphicBuffer;
+            if (image == EGL_NO_IMAGE_KHR) {
+                if (graphicBuffer == 0) {
+                    ST_LOGE("updateTexImage: buffer at slot %d is null", buf);
+                    err = BAD_VALUE;
+                } else {
+                    image = createImage(dpy, graphicBuffer);
+                    mEGLSlots[buf].mEglImage = image;
+                    mEGLSlots[buf].mEglDisplay = dpy;
+                    if (image == EGL_NO_IMAGE_KHR) {
+                        // NOTE: if dpy was invalid, createImage() is guaranteed to
+                        // fail. so we'd end up here.
+                        err = UNKNOWN_ERROR;
+                    }
                 }
             }
         }
@@ -310,7 +419,7 @@
 
         // Update the SurfaceTexture state.
         mCurrentTexture = buf;
-        mCurrentTextureBuf = mEGLSlots[buf].mGraphicBuffer;
+        mCurrentTextureBuf = graphicBuffer;
         mCurrentCrop = item.mCrop;
         mCurrentTransform = item.mTransform;
         mCurrentScalingMode = item.mScalingMode;
@@ -503,8 +612,12 @@
     case HAL_PIXEL_FORMAT_YV12:
     // Legacy/deprecated YUV formats
     case HAL_PIXEL_FORMAT_YCbCr_422_SP:
-    case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+    case HAL_PIXEL_FORMAT_YCbCr_420_SP:
     case HAL_PIXEL_FORMAT_YCbCr_422_I:
+    case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+    case HAL_PIXEL_FORMAT_YCrCb_422_P:
+    case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+    case HAL_PIXEL_FORMAT_YCrCb_420_P:
         return true;
     }
 
@@ -712,6 +825,12 @@
 
 void SurfaceTexture::freeBufferLocked(int slotIndex) {
     ST_LOGV("freeBufferLocked: slotIndex=%d", slotIndex);
+
+    // Check is we have a pending conversion before free.
+    if (mConvertPending) {
+        convert();
+    }
+
     mEGLSlots[slotIndex].mGraphicBuffer = 0;
     if (slotIndex == mCurrentTexture) {
         mCurrentTexture = BufferQueue::INVALID_BUFFER_SLOT;
@@ -737,6 +856,15 @@
             freeBufferLocked(i);
         }
 
+        for (int i = 0; i < NUM_BLIT_BUFFER_SLOTS; i++) {
+            mBlitSlots[i].mGraphicBuffer = 0;
+            if (mBlitSlots[i].mEglImage != EGL_NO_IMAGE_KHR) {
+                eglDestroyImageKHR(mBlitSlots[i].mEglDisplay, mBlitSlots[i].mEglImage);
+                mBlitSlots[i].mEglImage = EGL_NO_IMAGE_KHR;
+                mBlitSlots[i].mEglDisplay = EGL_NO_DISPLAY;
+            }
+        }
+
         // disconnect from the BufferQueue
         mBufferQueue->consumerDisconnect();
         mBufferQueue.clear();
@@ -839,6 +967,85 @@
     }
 }
 
+bool SurfaceTexture::conversionIsNeeded(const sp<GraphicBuffer>& graphicBuffer) {
+    int fmt = graphicBuffer->getPixelFormat();
+    return (fmt == PIXEL_FORMAT_YCBCR42XMBN)
+            || (fmt == PIXEL_FORMAT_YCbCr_420_P)
+            || (fmt == PIXEL_FORMAT_YCbCr_420_SP)
+            || (fmt == PIXEL_FORMAT_YCbCr_422_I);
+}
+
+status_t SurfaceTexture::convert() {
+    if (!mNeedsConversion)
+        return NO_ERROR;
+
+    if (mConversionBltSlot < 0 ||
+            mConversionBltSlot >= NUM_BLIT_BUFFER_SLOTS ||
+            mConversionSrcSlot < 0 ||
+            mConversionSrcSlot >= BufferQueue::NUM_BUFFER_SLOTS) {
+        ALOGE_IF(STE_DEFERDBG, "%s: Incorrect setup for deferred "
+            "texture conversion:\n"
+            "mConversionSrcSlot=%d mConversionBltSlot=%d", __FUNCTION__,
+            mConversionSrcSlot, mConversionBltSlot);
+        return BAD_VALUE;
+    }
+
+    if (mEGLSlots[mConversionSrcSlot].mGraphicBuffer == NULL) {
+        ALOGI_IF(STE_DEFERDBG, "%s: NULL source for deferred texture conversion.",
+            __FUNCTION__);
+        return OK;
+    }
+
+    if (mBlitSlots[mConversionBltSlot].mGraphicBuffer == NULL) {
+        ALOGI_IF(STE_DEFERDBG, "%s: NULL destination for deferred "
+            "texture conversion.", __FUNCTION__);
+        return OK;
+    }
+    mConvertPending = false;
+    return convert(mEGLSlots[mConversionSrcSlot].mGraphicBuffer,
+        mBlitSlots[mConversionBltSlot].mGraphicBuffer);
+}
+
+status_t SurfaceTexture::convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf) {
+    copybit_image_t dstImg;
+    dstImg.w = dstBuf->getWidth();
+    dstImg.h = dstBuf->getHeight();
+    dstImg.format = dstBuf->getPixelFormat();
+    dstImg.handle = (native_handle_t*) dstBuf->getNativeBuffer()->handle;
+
+    copybit_image_t srcImg;
+    srcImg.w = srcBuf->getWidth();
+    srcImg.h = srcBuf->getHeight();
+    srcImg.format = srcBuf->getPixelFormat();
+    srcImg.base = NULL;
+    srcImg.handle = (native_handle_t*) srcBuf->getNativeBuffer()->handle;
+
+    copybit_rect_t dstCrop;
+    dstCrop.l = 0;
+    dstCrop.t = 0;
+    dstCrop.r = dstBuf->getWidth();
+    dstCrop.b = dstBuf->getHeight();
+
+    copybit_rect_t srcCrop;
+    srcCrop.l = 0;
+    srcCrop.t = 0;
+    srcCrop.r = srcBuf->getWidth();
+    srcCrop.b = srcBuf->getHeight();
+
+    region_iterator clip(Region(Rect(dstCrop.r, dstCrop.b)));
+    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_TRANSFORM, 0);
+    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_PLANE_ALPHA, 0xFF);
+    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_DITHER, COPYBIT_ENABLE);
+
+    int err = mBlitEngine->stretch(
+            mBlitEngine, &dstImg, &srcImg, &dstCrop, &srcCrop, &clip);
+    if (err != 0) {
+        ALOGE("\nError: Blit stretch operation failed (err:%d)\n", err);
+        return UNKNOWN_ERROR;
+    }
+    return OK;
+}
+
 static void mtxMul(float out[16], const float a[16], const float b[16]) {
     out[0] = a[0]*b[0] + a[4]*b[1] + a[8]*b[2] + a[12]*b[3];
     out[1] = a[1]*b[0] + a[5]*b[1] + a[9]*b[2] + a[13]*b[3];
diff -ruN /home/meticulus/native/libs/ui/Android.mk /media/Exhibit/s1-4.1/frameworks/native/libs/ui/Android.mk
--- /home/meticulus/native/libs/ui/Android.mk	2014-10-06 12:29:18.027839926 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/libs/ui/Android.mk	2014-01-07 19:45:46.000000000 -0600
@@ -24,6 +24,10 @@
 	Rect.cpp \
 	Region.cpp
 
+ifdef BOARD_NUM_FRAME_BUFFERS
+LOCAL_CFLAGS:= -DNUM_FRAME_BUFFERS=$(BOARD_NUM_FRAME_BUFFERS)
+endif
+
 LOCAL_SHARED_LIBRARIES := \
 	libcutils \
 	libutils \
diff -ruN /home/meticulus/native/libs/ui/FramebufferNativeWindow.cpp /media/Exhibit/s1-4.1/frameworks/native/libs/ui/FramebufferNativeWindow.cpp
--- /home/meticulus/native/libs/ui/FramebufferNativeWindow.cpp	2014-10-06 12:29:18.027839926 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/libs/ui/FramebufferNativeWindow.cpp	2014-01-07 19:45:46.000000000 -0600
@@ -71,8 +71,8 @@
  * 
  */
 
-FramebufferNativeWindow::FramebufferNativeWindow() 
-    : BASE(), fbDev(0), grDev(0), mUpdateOnDemand(false)
+FramebufferNativeWindow::FramebufferNativeWindow()
+    : BASE(), fbDev(0), grDev(0), mUpdateOnDemand(false), mDiscardQueuedBuffersCnt(0)
 {
     hw_module_t const* module;
     if (hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module) == 0) {
@@ -149,6 +149,7 @@
     ANativeWindow::queueBuffer = queueBuffer;
     ANativeWindow::query = query;
     ANativeWindow::perform = perform;
+    ANativeWindow::cancelBuffer = cancelBuffer;
 }
 
 FramebufferNativeWindow::~FramebufferNativeWindow() 
@@ -182,6 +183,50 @@
     return INVALID_OPERATION;
 }
 
+void FramebufferNativeWindow::UIRotationChange(int uiRotation)
+{
+    if (fbDev->UIRotationChange)
+        fbDev->UIRotationChange(fbDev, uiRotation);
+}
+
+void FramebufferNativeWindow::enableHDMIMirroring(bool enable)
+{
+    if (fbDev->enableHDMIMirroring)
+        fbDev->enableHDMIMirroring(fbDev, enable);
+}
+
+status_t FramebufferNativeWindow::rotate(unsigned int absoluteDegree)
+{
+    Mutex::Autolock _l(mutex);
+    int ret;
+
+    if (fbDev->rotate == NULL)
+        return INVALID_OPERATION;
+
+    ret = fbDev->rotate(fbDev, absoluteDegree);
+    if (ret < 0)
+        /*
+         * Android's error codes seem to match errno, at least the
+         * important stuff.
+         */
+        return ret;
+
+    const_cast<float&>(xdpi) = fbDev->xdpi;
+    const_cast<float&>(ydpi) = fbDev->ydpi;
+
+    return NO_ERROR;
+}
+
+void FramebufferNativeWindow::discardQueuedBuffers(bool on)
+{
+    Mutex::Autolock _l(mutex);
+
+    if (on)
+        mDiscardQueuedBuffersCnt++;
+    else
+        mDiscardQueuedBuffersCnt--;
+}
+
 int FramebufferNativeWindow::setSwapInterval(
         ANativeWindow* window, int interval) 
 {
@@ -226,6 +271,10 @@
     self->mNumFreeBuffers--;
     self->mCurrentBufferIndex = index;
 
+    self->buffers[index]->width = fb->width;
+    self->buffers[index]->height = fb->height;
+    self->buffers[index]->stride = fb->stride;
+
     *buffer = self->buffers[index].get();
 
     return 0;
@@ -253,11 +302,25 @@
     FramebufferNativeWindow* self = getSelf(window);
     Mutex::Autolock _l(self->mutex);
     framebuffer_device_t* fb = self->fbDev;
-    buffer_handle_t handle = static_cast<NativeBuffer*>(buffer)->handle;
+    NativeBuffer* handle = static_cast<NativeBuffer*>(buffer);
+
+    int res = 0;
+    if (self->mDiscardQueuedBuffersCnt > 0) {
+       /*
+         * Not perfect but in line with how the problem is handled
+         * for app wins which is the most important thing as EGL
+         * implementations make no difference between the FB win
+         * and app wins.
+         */
+        /* Essentially self->mBufferHead-- */
+        self->mBufferHead = (self->mBufferHead + self->mNumBuffers - 1) %
+                self->mNumBuffers;
+    } else {
+        const int index = self->mCurrentBufferIndex;
+        res = fb->post(fb, handle->handle);
+        self->front = handle;
+    }
 
-    const int index = self->mCurrentBufferIndex;
-    int res = fb->post(fb, handle);
-    self->front = static_cast<NativeBuffer*>(buffer);
     self->mNumFreeBuffers++;
     self->mCondition.broadcast();
     return res;
@@ -326,6 +389,27 @@
     return NAME_NOT_FOUND;
 }
 
+int FramebufferNativeWindow::cancelBuffer(ANativeWindow* window,
+        android_native_buffer_t* buffer)
+{
+    FramebufferNativeWindow* self = getSelf(window);
+    Mutex::Autolock _l(self->mutex);
+
+    /*
+     * Not perfect but in line with how the problem is handled
+     * for app wins which is the most important thing as EGL
+     * implementations make no difference between the fb window
+     * and app windows.
+     */
+    /* Essentially self->mBufferHead-- */
+    self->mBufferHead = (self->mBufferHead + self->mNumBuffers - 1) %
+        self->mNumBuffers;
+    self->mNumFreeBuffers++;
+    self->mCondition.broadcast();
+
+    return NO_ERROR;
+}
+
 // ----------------------------------------------------------------------------
 }; // namespace android
 // ----------------------------------------------------------------------------
diff -ruN /home/meticulus/native/libs/ui/PixelFormat.cpp /media/Exhibit/s1-4.1/frameworks/native/libs/ui/PixelFormat.cpp
--- /home/meticulus/native/libs/ui/PixelFormat.cpp	2014-10-06 12:29:18.027839926 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/libs/ui/PixelFormat.cpp	2014-01-07 19:45:46.000000000 -0600
@@ -100,11 +100,21 @@
     // YUV format from the HAL are handled here
     switch (format) {
     case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+    case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+    case HAL_PIXEL_FORMAT_YCbCr_422_P:
     case HAL_PIXEL_FORMAT_YCbCr_422_I:
+    case HAL_PIXEL_FORMAT_CbYCrY_422_I:
         info->bitsPerPixel = 16;
         goto done;
+    case HAL_PIXEL_FORMAT_YCbCr_420_SP:
     case HAL_PIXEL_FORMAT_YCrCb_420_SP:
     case HAL_PIXEL_FORMAT_YV12:
+    case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED:
+    case HAL_PIXEL_FORMAT_YCrCb_420_SP_TILED:
+    case HAL_PIXEL_FORMAT_YCbCr_420_P:
+    case HAL_PIXEL_FORMAT_YCbCr_420_I:
+    case HAL_PIXEL_FORMAT_CbYCrY_420_I:
+    case HAL_PIXEL_FORMAT_YCBCR42XMBN:
         info->bitsPerPixel = 12;
      done:
         info->format = format;
diff -ruN /home/meticulus/native/opengl/include/EGL/eglext.h /media/Exhibit/s1-4.1/frameworks/native/opengl/include/EGL/eglext.h
--- /home/meticulus/native/opengl/include/EGL/eglext.h	2014-10-06 12:29:18.035839926 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/opengl/include/EGL/eglext.h	2014-01-07 19:45:46.000000000 -0600
@@ -236,6 +236,7 @@
 
 /* EGL_NV_system_time
  */
+/*
 #ifndef EGL_NV_system_time
 #define EGL_NV_system_time 1
 typedef khronos_int64_t EGLint64NV;
@@ -247,6 +248,7 @@
 typedef EGLuint64NV (EGLAPIENTRYP PFNEGLGETSYSTEMTIMEFREQUENCYNVPROC)(void);
 typedef EGLuint64NV (EGLAPIENTRYP PFNEGLGETSYSTEMTIMENVPROC)(void);
 #endif
+*/
 
 /* EGL_ANDROID_blob_cache
  */
diff -ruN /home/meticulus/native/opengl/libs/Android.mk /media/Exhibit/s1-4.1/frameworks/native/opengl/libs/Android.mk
--- /home/meticulus/native/opengl/libs/Android.mk	2014-10-06 12:29:18.047839926 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/opengl/libs/Android.mk	2014-01-07 19:45:46.000000000 -0600
@@ -61,6 +61,10 @@
   LOCAL_CFLAGS += -DMAX_EGL_CACHE_SIZE=$(MAX_EGL_CACHE_SIZE)
 endif
 
+ifeq ($(ENABLE_FEATURE_FORCE_CLEAR), true)
+	LOCAL_CFLAGS += -DHAS_FORCE_CLEAR
+endif
+
 include $(BUILD_SHARED_LIBRARY)
 installed_libEGL := $(LOCAL_INSTALLED_MODULE)
 
diff -ruN /home/meticulus/native/opengl/libs/EGL/eglApi.cpp /media/Exhibit/s1-4.1/frameworks/native/opengl/libs/EGL/eglApi.cpp
--- /home/meticulus/native/opengl/libs/EGL/eglApi.cpp	2014-10-06 12:29:18.047839926 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/opengl/libs/EGL/eglApi.cpp	2014-01-07 19:45:46.000000000 -0600
@@ -70,10 +70,10 @@
             (__eglMustCastToProperFunctionPointerType)&eglCreateImageKHR },
     { "eglDestroyImageKHR",
             (__eglMustCastToProperFunctionPointerType)&eglDestroyImageKHR },
-    { "eglGetSystemTimeFrequencyNV",
+    /*{ "eglGetSystemTimeFrequencyNV",
             (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
     { "eglGetSystemTimeNV",
-            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
+    (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },*/
 };
 
 // accesses protected by sExtensionMapMutex
@@ -815,6 +815,18 @@
 
     EGLBoolean result = s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
 
+#ifdef HAS_FORCE_CLEAR
+    //We clear the next frame before giving it to the application.
+    GLboolean hasScissorTest = GL_FALSE;
+    s->cnx->hooks[egl_connection_t::GLESv1_INDEX]->gl.glGetBooleanv(GL_SCISSOR_TEST,
+                                                                    &hasScissorTest);
+    if (hasScissorTest)
+        s->cnx->hooks[egl_connection_t::GLESv1_INDEX]->gl.glDisable(GL_SCISSOR_TEST);
+    s->cnx->hooks[egl_connection_t::GLESv1_INDEX]->gl.glClear(GL_COLOR_BUFFER_BIT);
+    if (hasScissorTest)
+        s->cnx->hooks[egl_connection_t::GLESv1_INDEX]->gl.glEnable(GL_SCISSOR_TEST);
+#endif
+
     if (CC_UNLIKELY(dp->traceGpuCompletion)) {
         EGLSyncKHR sync = EGL_NO_SYNC_KHR;
         {
@@ -1195,7 +1207,7 @@
 // ----------------------------------------------------------------------------
 // NVIDIA extensions
 // ----------------------------------------------------------------------------
-EGLuint64NV eglGetSystemTimeFrequencyNV()
+/*EGLuint64NV eglGetSystemTimeFrequencyNV()
 {
     clearError();
 
@@ -1230,3 +1242,4 @@
 
     return setErrorQuiet(EGL_BAD_DISPLAY, 0);
 }
+*/
diff -ruN /home/meticulus/native/opengl/libs/EGL/egl_display.cpp /media/Exhibit/s1-4.1/frameworks/native/opengl/libs/EGL/egl_display.cpp
--- /home/meticulus/native/opengl/libs/EGL/egl_display.cpp	2014-10-06 12:29:18.047839926 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/opengl/libs/EGL/egl_display.cpp	2014-01-07 19:45:46.000000000 -0600
@@ -52,7 +52,7 @@
         "EGL_KHR_gl_texture_cubemap_image "
         "EGL_KHR_gl_renderbuffer_image "
         "EGL_KHR_fence_sync "
-        "EGL_NV_system_time "
+//        "EGL_NV_system_time "
         "EGL_ANDROID_image_native_buffer "      // mandatory
         ;
 
diff -ruN /home/meticulus/native/opengl/libs/EGL/egl_entries.in /media/Exhibit/s1-4.1/frameworks/native/opengl/libs/EGL/egl_entries.in
--- /home/meticulus/native/opengl/libs/EGL/egl_entries.in	2014-10-06 12:29:18.047839926 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/opengl/libs/EGL/egl_entries.in	2014-01-07 19:45:46.000000000 -0600
@@ -64,10 +64,10 @@
 EGL_ENTRY(EGLClientBuffer, eglGetRenderBufferANDROID, EGLDisplay, EGLSurface)
 
 /* NVIDIA extensions */
-
+/*
 EGL_ENTRY(EGLuint64NV, eglGetSystemTimeFrequencyNV, void)
 EGL_ENTRY(EGLuint64NV, eglGetSystemTimeNV, void)
-
+*/
 /* IMG extensions */
 
 EGL_ENTRY(EGLBoolean, eglHibernateProcessIMG, void)
diff -ruN /home/meticulus/native/services/surfaceflinger/Android.mk /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/Android.mk
--- /home/meticulus/native/services/surfaceflinger/Android.mk	2014-10-06 12:29:18.083839928 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/Android.mk	2014-01-07 19:45:47.000000000 -0600
@@ -21,6 +21,10 @@
 LOCAL_CFLAGS:= -DLOG_TAG=\"SurfaceFlinger\"
 LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES
 
+#ifeq ($(SF_ENABLE_FEATURE_FB_ROTATION), true)
+#	LOCAL_CFLAGS += -DFB_ROTATION
+#endif
+
 ifeq ($(TARGET_BOARD_PLATFORM), omap3)
 	LOCAL_CFLAGS += -DNO_RGBX_8888
 endif
diff -ruN /home/meticulus/native/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
--- /home/meticulus/native/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp	2014-10-06 12:29:18.083839928 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp	2014-01-07 19:45:47.000000000 -0600
@@ -301,6 +301,7 @@
     mContext = context;
     mFormat  = fbDev->format;
     mPageFlipCount = 0;
+    mHDMIOutputMode = 0;
 
     /*
      * Gather OpenGL ES extensions
@@ -431,6 +432,61 @@
     return mNativeWindow->compositionComplete();
 }
 
+status_t DisplayHardware::rotate(unsigned int absoluteDegree)
+{
+    status_t ret;
+
+    if (mDisplay != eglGetCurrentDisplay() ||
+        mContext != eglGetCurrentContext() ||
+        mSurface != eglGetCurrentSurface(EGL_DRAW) ||
+        mSurface != eglGetCurrentSurface(EGL_READ)) {
+        ALOGW("Wrong current context/surface, display hw rotation disabled. Multiple"
+            " instances of DisplayHardware? Has surface flinger started using non"
+            "-DisplayHardware contexts?");
+        return UNKNOWN_ERROR;
+    }
+
+    /*
+     * Destroy surface, rotate FB and then re-create the surface to force EGL to notice
+     * the change.
+     */
+
+    /*
+     * We don't want to see any half rendered frames sent to the window as a result
+     * of the destroy process.
+     */
+    mNativeWindow->discardQueuedBuffers(true);
+
+    eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    /*
+     * No need to worry about the content as everything is repainted after a rotate
+     * (even when it fails, in which case the rotation will be done in gl).
+     */
+    eglDestroySurface(mDisplay, mSurface);
+
+    mNativeWindow->discardQueuedBuffers(false);
+
+    ret = mNativeWindow->rotate(absoluteDegree);
+
+    mSurface = eglCreateWindowSurface(mDisplay, mConfig, mNativeWindow.get(), NULL);
+    if (mSurface == EGL_NO_SURFACE)
+        ALOGE("Failed to re-create surface (error %i). Not handled, corrupt state!",
+            eglGetError());
+    eglMakeCurrent(mDisplay, mSurface, mSurface, mContext);
+
+    eglQuerySurface(mDisplay, mSurface, EGL_WIDTH,  &mWidth);
+    eglQuerySurface(mDisplay, mSurface, EGL_HEIGHT, &mHeight);
+
+    if (mHwc->initCheck() == NO_ERROR) {
+        mHwc->setFrameBuffer(mDisplay, mSurface);
+    }
+
+    mDpiX = mNativeWindow->xdpi;
+    mDpiY = mNativeWindow->ydpi;
+
+    return ret;
+}
+
 void DisplayHardware::flip(const Region& dirty) const
 {
     checkGLErrors();
@@ -456,6 +512,8 @@
     if (mHwc->initCheck() == NO_ERROR) {
         mHwc->commit();
     } else {
+        // Make sure the swapbuffer call is done in sync
+        mNativeWindow->compositionComplete();
         eglSwapBuffers(dpy, surface);
     }
     checkEGLErrors("eglSwapBuffers");
@@ -479,3 +537,52 @@
 {
     mNativeWindow->dump(res);
 }
+
+void DisplayHardware::handleHDMIModeChange(uint32_t mode) const
+{
+    /*
+     * HDMIMirroring is enabled when the UI should be mirrored on the
+     * external device. In some cases e.g. HDMI_MODE_CLONE
+     * the UI is not mirrored when overlay is mirrored.
+     */
+    switch (mode) {
+        case HDMI_MODE_OFF:
+            mNativeWindow->enableHDMIMirroring(false);
+            if (mHwc->initCheck() == NO_ERROR)
+                mHwc->setParameter(HWC_HDMI_PLUGGED, 0);
+            break;
+        case HDMI_MODE_CLONE:
+                mNativeWindow->enableHDMIMirroring(true);
+            if (mHwc->initCheck() == NO_ERROR)
+                mHwc->setParameter(HWC_HDMI_PLUGGED, 1);
+            break;
+        case HDMI_MODE_CLONE_UI_ONLY:
+            mNativeWindow->enableHDMIMirroring(true);
+            if (mHwc->initCheck() == NO_ERROR)
+                mHwc->setParameter(HWC_HDMI_PLUGGED, 1);
+            break;
+        case HDMI_MODE_CLONE_OVERLAY_ONLY:
+            mNativeWindow->enableHDMIMirroring(false);
+            if (mHwc->initCheck() == NO_ERROR)
+                mHwc->setParameter(HWC_HDMI_PLUGGED, 0);
+            break;
+        default:
+            mNativeWindow->enableHDMIMirroring(false);
+            if (mHwc->initCheck() == NO_ERROR)
+                mHwc->setParameter(HWC_HDMI_PLUGGED, 0);
+    }
+}
+
+void DisplayHardware::UIRotationChange(int uiRotation) const
+{
+    mNativeWindow->UIRotationChange(uiRotation);
+}
+
+status_t DisplayHardware::setHDMIOutputMode(uint32_t mode) const
+{
+    if (mHDMIOutputMode != mode) {
+        mHDMIOutputMode = mode;
+        handleHDMIModeChange(mHDMIOutputMode);
+    }
+    return 0;
+}
diff -ruN /home/meticulus/native/services/surfaceflinger/DisplayHardware/DisplayHardware.h /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardware.h
--- /home/meticulus/native/services/surfaceflinger/DisplayHardware/DisplayHardware.h	2014-10-06 12:29:18.083839928 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardware.h	2014-01-07 19:45:47.000000000 -0600
@@ -57,6 +57,14 @@
         SWAP_RECTANGLE              = 0x00080000,
     };
 
+    // flags for HDMI Modes
+    enum {
+        HDMI_MODE_OFF                   = 0,
+        HDMI_MODE_CLONE                 = 1,
+        HDMI_MODE_CLONE_UI_ONLY         = 2,
+        HDMI_MODE_CLONE_OVERLAY_ONLY    = 3,
+    };
+
     DisplayHardware(
             const sp<SurfaceFlinger>& flinger,
             uint32_t displayIndex);
@@ -66,6 +74,12 @@
     void releaseScreen() const;
     void acquireScreen() const;
 
+    status_t rotate(unsigned int absoluteDegree);
+
+    void handleHDMIModeChange(uint32_t mode) const;
+    void UIRotationChange(int uiRotation) const;
+    status_t setHDMIOutputMode(uint32_t mode) const;
+
     // Flip the front and back buffers if the back buffer is "dirty".  Might
     // be instantaneous, might involve copying the frame buffer around.
     void flip(const Region& dirty) const;
@@ -101,9 +115,9 @@
 
     // Hardware Composer
     HWComposer& getHwComposer() const;
-    
+
     status_t compositionComplete() const;
-    
+
     Rect getBounds() const {
         return Rect(mWidth, mHeight);
     }
@@ -130,6 +144,7 @@
     mutable uint32_t mPageFlipCount;
     GLint           mMaxViewportDims[2];
     GLint           mMaxTextureSize;
+    mutable uint32_t mHDMIOutputMode;
 
     nsecs_t         mRefreshPeriod;
     mutable nsecs_t mLastHwVSync;
diff -ruN /home/meticulus/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
--- /home/meticulus/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	2014-10-06 12:29:18.083839928 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	2014-01-07 19:45:47.000000000 -0600
@@ -153,6 +153,7 @@
             free(mList);
             size_t size = sizeof(hwc_layer_list) + numLayers*sizeof(hwc_layer_t);
             mList = (hwc_layer_list_t*)malloc(size);
+            memset(mList, 0, size);
             mCapacity = numLayers;
         }
         mList->flags = HWC_GEOMETRY_CHANGED;
@@ -234,6 +235,17 @@
     return mList ? mList->hwLayers : 0;
 }
 
+status_t HWComposer::setParameter(int param, int value) const {
+#ifdef HWC_DEVICE_API_VERSION_0_3_STE
+    if (mHwc && mHwc->common.version >= HWC_DEVICE_API_VERSION_0_3_STE
+                                            && mHwc->methods->setParameter) {
+        int err = mHwc->methods->setParameter(mHwc, param, value);
+        return (status_t)err;
+    }
+#endif /* HWC_DEVICE_API_VERSION_0_3_STE */
+    return  NO_ERROR;
+}
+
 void HWComposer::dump(String8& result, char* buffer, size_t SIZE,
         const Vector< sp<LayerBase> >& visibleLayersSortedByZ) const {
     if (mHwc && mList) {
diff -ruN /home/meticulus/native/services/surfaceflinger/DisplayHardware/HWComposer.h /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h
--- /home/meticulus/native/services/surfaceflinger/DisplayHardware/HWComposer.h	2014-10-06 12:29:18.087839928 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h	2014-01-07 19:45:47.000000000 -0600
@@ -80,6 +80,9 @@
     // type is HWC_OVERLAY or HWC_FRAMEBUFFER
     size_t getLayerCount(int type) const;
 
+    // vendor specific hook for setting specific parameters in hwcomposer.
+    status_t setParameter(int param, int value) const;
+
     // Events handling ---------------------------------------------------------
 
     enum {
diff -ruN /home/meticulus/native/services/surfaceflinger/Layer.cpp /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/Layer.cpp
--- /home/meticulus/native/services/surfaceflinger/Layer.cpp	2014-10-06 12:29:18.087839928 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/Layer.cpp	2014-01-07 19:45:47.000000000 -0600
@@ -317,6 +317,16 @@
 {
     ATRACE_CALL();
 
+    // Convert the texture to a native format if need be.
+    // convert() returns immediately if no conversion is necessary.
+    if (mSurfaceTexture != NULL) {
+        status_t res = mSurfaceTexture->convert();
+        if (res != NO_ERROR) {
+            ALOGE("Layer::onDraw: texture conversion failed. "
+                "Texture content for this layer will not be initialized.");
+        }
+    }
+
     if (CC_UNLIKELY(mActiveBuffer == 0)) {
         // the texture has not been created yet, this Layer has
         // in fact never been drawn into. This happens frequently with
@@ -624,7 +634,7 @@
 
         Reject r(mDrawingState, currentState(), recomputeVisibleRegions);
 
-        if (mSurfaceTexture->updateTexImage(&r) < NO_ERROR) {
+	if (mSurfaceTexture->updateTexImage(&r, true) < NO_ERROR) {
             // something happened!
             recomputeVisibleRegions = true;
             return;
diff -ruN /home/meticulus/native/services/surfaceflinger/SurfaceFlinger.cpp /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
--- /home/meticulus/native/services/surfaceflinger/SurfaceFlinger.cpp	2014-10-06 12:29:18.091839928 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2014-01-07 19:45:47.000000000 -0600
@@ -445,7 +445,7 @@
                 // repaint the framebuffer (if needed)
                 handleRepaint();
                 // inform the h/w that we're done compositing
-                hw.compositionComplete();
+                //hw.compositionComplete();
                 postFramebuffer();
             } else {
                 // pretend we did the post
@@ -508,6 +508,37 @@
     const LayerVector& currentLayers(mCurrentState.layersSortedByZ);
     const size_t count = currentLayers.size();
 
+    if (transactionFlags & eTransactionNeeded) {
+        if (mCurrentState.HDMIOutputMode != mDrawingState.HDMIOutputMode) {
+            const int dpy = 0;
+            GraphicPlane& plane(graphicPlane(dpy));
+            const DisplayHardware& hw(plane.displayHardware());
+            uint32_t HDMIOutputMode;
+
+            switch (mCurrentState.HDMIOutputMode) {
+                case ISurfaceComposer::eHDMIModeOff:
+                    HDMIOutputMode = DisplayHardware::HDMI_MODE_OFF;
+                    break;
+                case ISurfaceComposer::eHDMIModeClone:
+                    HDMIOutputMode = DisplayHardware::HDMI_MODE_CLONE;
+                    break;
+                case ISurfaceComposer::eHDMIModeCloneUIOnly:
+                    HDMIOutputMode = DisplayHardware::HDMI_MODE_CLONE_UI_ONLY;
+                    break;
+                case ISurfaceComposer::eHDMIModeCloneOverlayOnly:
+                    HDMIOutputMode = DisplayHardware::HDMI_MODE_CLONE_OVERLAY_ONLY;
+                    break;
+                default:
+                    HDMIOutputMode = DisplayHardware::HDMI_MODE_OFF;
+            }
+            hw.setHDMIOutputMode(HDMIOutputMode);
+            for (size_t i=0 ; i<count ; i++) {
+                const sp<LayerBase>& layer = currentLayers[i];
+                layer->requestTransaction();
+            }
+        }
+    }
+
     /*
      * Traversal of the children
      * (perform the transaction for each of them if needed)
@@ -539,6 +570,9 @@
             const int orientation = mCurrentState.orientation;
             // Currently unused: const uint32_t flags = mCurrentState.orientationFlags;
             GraphicPlane& plane(graphicPlane(dpy));
+            int hwWidth, hwHeight;
+            HWComposer& hwc(graphicPlane(0).displayHardware().getHwComposer());
+
             plane.setOrientation(orientation);
 
             // update the shared control block
@@ -550,6 +584,17 @@
 
             mVisibleRegionsDirty = true;
             mDirtyRegion.set(hw.bounds());
+
+            hwWidth = hw.getWidth();
+            hwHeight = hw.getHeight();
+
+            glViewport(0, 0, hwWidth, hwHeight);
+            glMatrixMode(GL_PROJECTION);
+            glLoadIdentity();
+            glOrthof(0, hwWidth, 0, hwHeight, 0, 1); // l=0, r=w ; b=0, t=h
+
+            if (mCurrentState.HDMIOutputMode != ISurfaceComposer::eHDMIModeOff)
+                hw.UIRotationChange(orientation);
         }
 
         if (currentLayers.size() > mDrawingState.layersSortedByZ.size()) {
@@ -833,8 +878,8 @@
 
     // set the frame buffer
     const DisplayHardware& hw(graphicPlane(0).displayHardware());
-    glMatrixMode(GL_MODELVIEW);
-    glLoadIdentity();
+    //glMatrixMode(GL_MODELVIEW);
+    //glLoadIdentity();
 
     uint32_t flags = hw.getFlags();
     if (flags & DisplayHardware::SWAP_RECTANGLE) {
@@ -864,8 +909,11 @@
     mDirtyRegion.clear();
 }
 
+static bool checkDrawingWithGL(hwc_layer_t* const layers, size_t layerCount);
+
 void SurfaceFlinger::setupHardwareComposer()
 {
+    bool useGL = true;
     const DisplayHardware& hw(graphicPlane(0).displayHardware());
     HWComposer& hwc(hw.getHwComposer());
     hwc_layer_t* const cur(hwc.getLayers());
@@ -895,6 +943,35 @@
     }
     status_t err = hwc.prepare();
     ALOGE_IF(err, "HWComposer::prepare failed (%s)", strerror(-err));
+
+    /*
+     * Check if GL will be used
+     */
+    useGL = checkDrawingWithGL(cur, count);
+
+    if (!useGL) {
+        return;
+    }
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
+    if (CC_UNLIKELY(!mWormholeRegion.isEmpty())) {
+        // should never happen unless the window manager has a bug
+        // draw something...
+        drawWormhole();
+    }
+}
+
+static bool checkDrawingWithGL(hwc_layer_t* const layers, size_t layerCount)
+{
+    bool useGL = false;
+    if (layers) {
+        for (size_t i=0 ; i<layerCount ; i++) {
+            if (layers[i].compositionType == HWC_FRAMEBUFFER) {
+                useGL = true;
+            }
+        }
+    }
+    return useGL;
 }
 
 void SurfaceFlinger::composeSurfaces(const Region& dirty)
@@ -917,10 +994,10 @@
             glClear(GL_COLOR_BUFFER_BIT);
         } else {
             // screen is already cleared here
-            if (!mWormholeRegion.isEmpty()) {
+            //if (!mWormholeRegion.isEmpty()) {
                 // can happen with SurfaceView
-                drawWormhole();
-            }
+                //drawWormhole();
+            //}
         }
 
         /*
@@ -1166,6 +1243,17 @@
     }
 }
 
+status_t SurfaceFlinger::setHDMIOutputMode(uint32_t mode)
+{
+    Mutex::Autolock _l(mStateLock);
+    if (mCurrentState.HDMIOutputMode != mode) {
+        mCurrentState.HDMIOutputMode = mode;
+        setTransactionFlags(eTransactionNeeded | eTraversalNeeded);
+        mTransactionCV.wait(mStateLock);
+    }
+    return 0;
+}
+
 sp<ISurface> SurfaceFlinger::createSurface(
         ISurfaceComposerClient::surface_data_t* params,
         const String8& name,
@@ -1828,6 +1916,15 @@
     glDisable(GL_TEXTURE_2D);
     glClearColor(0,0,0,1);
     glClear(GL_COLOR_BUFFER_BIT);
+#ifdef FB_ROTATION
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    if (mDrawingState.orientation == 1)
+        glRotatef(-90, 0, 0, 1);
+    else if (mDrawingState.orientation == 3)
+        glRotatef(90, 0, 0, 1);
+    glOrthof(0, hw_w, 0, hw_h, 0, 1);
+#endif
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
     const Vector< sp<LayerBase> >& layers(mVisibleLayersSortedByZ);
@@ -1843,6 +1940,12 @@
     glBindFramebufferOES(GL_FRAMEBUFFER_OES, 0);
     glDeleteFramebuffersOES(1, &name);
 
+#ifdef FB_ROTATION
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    glOrthof(0, hw_w, 0, hw_h, 0, 1);
+#endif
+
     *textureName = tname;
     *uOut = u;
     *vOut = v;
@@ -1896,14 +1999,27 @@
     }
 
     GLfloat vtx[8];
-    const GLfloat texCoords[4][2] = { {0,0}, {0,v}, {u,v}, {u,0} };
+    const GLfloat (*texCoords)[4][2];
+    const GLfloat texCoords0[4][2] = { {0,0}, {0,v}, {u,v}, {u,0} };
+#ifdef FB_ROTATION
+    const GLfloat texCoords1[4][2] = { {0,v}, {u,v}, {u,0}, {0,0} };
+    const GLfloat texCoords3[4][2] = { {u,0}, {0,0}, {0,v}, {u,v} };
+
+    if (mDrawingState.orientation == 1)
+        texCoords = &texCoords1;
+    else if (mDrawingState.orientation == 3)
+        texCoords = &texCoords3;
+    else
+#endif
+        texCoords = &texCoords0;
+
     glBindTexture(GL_TEXTURE_2D, tname);
     glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-    glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
+    glTexCoordPointer(2, GL_FLOAT, 0, *texCoords);
     glEnableClientState(GL_TEXTURE_COORD_ARRAY);
     glVertexPointer(2, GL_FLOAT, 0, vtx);
 
@@ -2338,11 +2454,26 @@
     const uint32_t hw_w = hw.getWidth();
     const uint32_t hw_h = hw.getHeight();
 
-    if ((sw > hw_w) || (sh > hw_h))
-        return BAD_VALUE;
+#ifdef FB_ROTATION
+    if (mDrawingState.orientation == 0 || mDrawingState.orientation == 2) {
+#endif
+        if ((sw > hw_w) || (sh > hw_h))
+            return BAD_VALUE;
+
+        sw = (!sw) ? hw_w : sw;
+        sh = (!sh) ? hw_h : sh;
+#ifdef FB_ROTATION
+    } else {
+        // Draw landscape mode in landscape buffer
+        if ((sw > hw_h) || (sh > hw_w))
+            return BAD_VALUE;
+
+        uint32_t tmp = sw;
+        sw = (!sh) ? hw_w : sh;
+        sh = (!tmp) ? hw_h : tmp;
+    }
+#endif
 
-    sw = (!sw) ? hw_w : sw;
-    sh = (!sh) ? hw_h : sh;
     const size_t size = sw * sh * 4;
 
     //ALOGD("screenshot: sw=%d, sh=%d, minZ=%d, maxZ=%d",
@@ -2402,15 +2533,48 @@
                     new MemoryHeapBase(size, 0, "screen-capture") );
             void* const ptr = base->getBase();
             if (ptr) {
+                void *buf = NULL;
+#ifdef FB_ROTATION
+                if (mDrawingState.orientation == 1 || mDrawingState.orientation == 3) {
+                    buf = malloc(size);
+                } else
+#endif
+                {
+                    buf = ptr;
+                }
                 // capture the screen with glReadPixels()
                 ScopedTrace _t(ATRACE_TAG, "glReadPixels");
-                glReadPixels(0, 0, sw, sh, GL_RGBA, GL_UNSIGNED_BYTE, ptr);
+                glReadPixels(0, 0, sw, sh, GL_RGBA, GL_UNSIGNED_BYTE, buf);
                 if (glGetError() == GL_NO_ERROR) {
                     *heap = base;
-                    *w = sw;
-                    *h = sh;
                     *f = PIXEL_FORMAT_RGBA_8888;
                     result = NO_ERROR;
+
+#ifdef FB_ROTATION
+                    if (mDrawingState.orientation == 3 || mDrawingState.orientation == 1) {
+                        // Convert landscape buffer to portrait buffer
+                        for (uint32_t i = 0; i < sh; i++) {
+                            for (uint32_t j = 0; j < sw; j++) {
+                                uint32_t *tmp;
+                                if (mDrawingState.orientation == 3)
+                                    tmp = &((uint32_t *)ptr)[(sw - j - 1) * sh + i];
+                                else
+                                    tmp = &((uint32_t *)ptr)[j * sh + (sh - 1 - i)];
+
+                                *tmp = ((uint32_t *)buf)[i * sw + j];
+                            }
+                        }
+                        free(buf);
+                        // Reset orientation to portrait mode
+                        *w = sh;
+                        *h = sw;
+                    } else
+#endif
+                    {
+                        // Already in portrait mode
+                        *w = sw;
+                        *h = sh;
+                    }
                 }
             } else {
                 result = NO_MEMORY;
@@ -2648,9 +2812,9 @@
         if (err == NO_MEMORY) {
             GraphicBuffer::dumpAllocationsToSystemLog();
         }
-        ALOGE("GraphicBufferAlloc::createGraphicBuffer(w=%d, h=%d) "
+        ALOGE("GraphicBufferAlloc::createGraphicBuffer(w=%d, h=%d, format=%#x) "
              "failed (%s), handle=%p",
-                w, h, strerror(-err), graphicBuffer->handle);
+               w, h, format, strerror(-err), graphicBuffer->handle);
         return 0;
     }
     return graphicBuffer;
@@ -2661,6 +2825,16 @@
 GraphicPlane::GraphicPlane()
     : mHw(0)
 {
+    char value[PROPERTY_VALUE_MAX];
+    property_get("ro.sf.hwrotation", value, "0");
+    mDisplayRotation = atoi(value);
+    if (mDisplayRotation % 90 != 0 || mDisplayRotation <= INT_MIN + 360)
+        mDisplayRotation = 0;
+    if (mDisplayRotation < 0)
+        // Make positive
+        mDisplayRotation += ((mDisplayRotation / -360) + 1) * 360;
+    // Make >= 0, < 360
+    mDisplayRotation = normalizeDegree(mDisplayRotation);
 }
 
 GraphicPlane::~GraphicPlane() {
@@ -2683,82 +2857,71 @@
 {
     mHw = hw;
 
-    // initialize the display orientation transform.
-    // it's a constant that should come from the display driver.
-    int displayOrientation = ISurfaceComposer::eOrientationDefault;
-    char property[PROPERTY_VALUE_MAX];
-    if (property_get("ro.sf.hwrotation", property, NULL) > 0) {
-        //displayOrientation
-        switch (atoi(property)) {
-        case 90:
-            displayOrientation = ISurfaceComposer::eOrientation90;
-            break;
-        case 270:
-            displayOrientation = ISurfaceComposer::eOrientation270;
-            break;
-        }
-    }
-
-    const float w = hw->getWidth();
-    const float h = hw->getHeight();
-    GraphicPlane::orientationToTransfrom(displayOrientation, w, h,
-            &mDisplayTransform);
-    if (displayOrientation & ISurfaceComposer::eOrientationSwapMask) {
-        mDisplayWidth = h;
-        mDisplayHeight = w;
-    } else {
-        mDisplayWidth = w;
-        mDisplayHeight = h;
-    }
-
     setOrientation(ISurfaceComposer::eOrientationDefault);
 }
 
-status_t GraphicPlane::orientationToTransfrom(
-        int orientation, int w, int h, Transform* tr)
-{
-    uint32_t flags = 0;
-    switch (orientation) {
-    case ISurfaceComposer::eOrientationDefault:
-        flags = Transform::ROT_0;
-        break;
-    case ISurfaceComposer::eOrientation90:
-        flags = Transform::ROT_90;
-        break;
-    case ISurfaceComposer::eOrientation180:
-        flags = Transform::ROT_180;
-        break;
-    case ISurfaceComposer::eOrientation270:
-        flags = Transform::ROT_270;
-        break;
-    default:
-        return BAD_VALUE;
-    }
-    tr->set(flags, w, h);
-    return NO_ERROR;
-}
-
 status_t GraphicPlane::setOrientation(int orientation)
 {
     // If the rotation can be handled in hardware, this is where
     // the magic should happen.
 
-    const DisplayHardware& hw(displayHardware());
-    const float w = mDisplayWidth;
-    const float h = mDisplayHeight;
-    mWidth = int(w);
-    mHeight = int(h);
-
-    Transform orientationTransform;
-    GraphicPlane::orientationToTransfrom(orientation, w, h,
-            &orientationTransform);
-    if (orientation & ISurfaceComposer::eOrientationSwapMask) {
-        mWidth = int(h);
-        mHeight = int(w);
+    status_t ret;
+    unsigned int fbDegree;
+    unsigned int glDegree = 0;
+
+    ret = orientationToDegree(orientation, &fbDegree);
+    if (ret != NO_ERROR)
+        return ret;
+
+    /*
+     * ST-Ericsson: MCDE can't rotate 180 with video mode displays so we do 180
+     * rotations in GL, should be ok as a 180 rotation is a light operation
+     * (flip x + flip y).
+     */
+    if (fbDegree == 180) {
+        glDegree = normalizeDegree(glDegree + fbDegree);
+        fbDegree = 0;
+    }
+
+#ifdef FB_ROTATION
+    if (mHw->rotate(fbDegree) != NO_ERROR)
+#endif
+    {
+#ifdef FB_ROTATION
+        unsigned int invertedDisplayRotation = normalizeDegree(360 - mDisplayRotation);
+        // Restore "original" FB rotation
+        (void)mHw->rotate(invertedDisplayRotation);
+#endif
+
+        /*
+         * Make GL do everything.
+         */
+        glDegree = normalizeDegree(fbDegree + glDegree);
+        fbDegree = 0;
+    }
+
+    unsigned int glDegreeCw = normalizeDegree(360 - glDegree);
+
+    int fbWidth = mHw->getWidth();
+    int fbHeight = mHw->getHeight();
+
+    uint32_t orientFlags = degreeToOrientFlags(glDegreeCw);
+    unsigned int fbDegreeCw = normalizeDegree(360 - fbDegree);
+    mHw->getHwComposer().setParameter(HWC_HARDWARE_ROTATION, fbDegreeCw);
+    mHw->getHwComposer().setParameter(HWC_UI_ORIENTATION, glDegree);
+    if (mGlobalTransform.set(orientFlags, fbWidth, fbHeight) != NO_ERROR)
+        ALOGE("Can't create global transform. Not handled, corrupt state!");
+
+    if (glDegree % 180 == 0) {
+        mWidth = fbWidth;
+        mHeight = fbHeight;
+    } else {
+        mWidth = fbHeight;
+        mHeight = fbWidth;
     }
 
     mOrientation = orientation;
-    mGlobalTransform = mDisplayTransform * orientationTransform;
+
     return NO_ERROR;
 }
 
@@ -2778,6 +2941,54 @@
     return mHw->getEGLDisplay();
 }
 
+status_t GraphicPlane::orientationToDegree(int orientation, unsigned int *degree) const
+{
+    int invertedDisplayRotation = 360 - mDisplayRotation;
+
+    switch (orientation) {
+    case ISurfaceComposer::eOrientationDefault:
+        *degree = 0 + invertedDisplayRotation;
+        break;
+    case ISurfaceComposer::eOrientation90:
+        *degree = 270 + invertedDisplayRotation;
+        break;
+    case ISurfaceComposer::eOrientation180:
+        *degree = 180 + invertedDisplayRotation;
+        break;
+    case ISurfaceComposer::eOrientation270:
+        *degree = 90 + invertedDisplayRotation;
+        break;
+    default:
+        return BAD_VALUE;
+    }
+
+    *degree = normalizeDegree(*degree);
+
+    return NO_ERROR;
+}
+
+uint32_t GraphicPlane::degreeToOrientFlags(int degree) const
+{
+    switch (degree) {
+    case 0:
+        return Transform::ROT_0;
+    case 90:
+        return Transform::ROT_90;
+    case 180:
+        return Transform::ROT_180;
+    case 270:
+        return Transform::ROT_270;
+    default:
+        ALOGE("Illegal degree %i received. Not handled, corrupt state!", degree);
+        return Transform::ROT_0;
+    }
+}
+
+unsigned int GraphicPlane::normalizeDegree(unsigned int degree) const
+{
+    return degree % 360;
+}
+
 // ---------------------------------------------------------------------------
 
 }; // namespace android
diff -ruN /home/meticulus/native/services/surfaceflinger/SurfaceFlinger.h /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
--- /home/meticulus/native/services/surfaceflinger/SurfaceFlinger.h	2014-10-06 12:29:18.091839928 -0500
+++ /media/Exhibit/s1-4.1/frameworks/native/services/surfaceflinger/SurfaceFlinger.h	2014-01-07 19:45:47.000000000 -0600
@@ -105,9 +105,6 @@
 class GraphicPlane
 {
 public:
-    static status_t orientationToTransfrom(int orientation, int w, int h,
-            Transform* tr);
-
                                 GraphicPlane();
                                 ~GraphicPlane();
 
@@ -123,19 +120,21 @@
         DisplayHardware&        editDisplayHardware();
         const Transform&        transform() const;
         EGLDisplay              getEGLDisplay() const;
-        
+
 private:
                                 GraphicPlane(const GraphicPlane&);
         GraphicPlane            operator = (const GraphicPlane&);
 
+        status_t                orientationToDegree(int orientation, unsigned int *degree) const;
+        uint32_t                degreeToOrientFlags(int degree) const;
+        unsigned int            normalizeDegree(unsigned int degree) const;
+
         DisplayHardware*        mHw;
         Transform               mGlobalTransform;
-        Transform               mDisplayTransform;
         int                     mOrientation;
-        float                   mDisplayWidth;
-        float                   mDisplayHeight;
         int                     mWidth;
         int                     mHeight;
+        int                     mDisplayRotation;
 };
 
 // ---------------------------------------------------------------------------
@@ -182,6 +181,8 @@
     virtual status_t                    turnElectronBeamOff(int32_t mode);
     virtual status_t                    turnElectronBeamOn(int32_t mode);
 
+    virtual status_t                    setHDMIOutputMode(uint32_t mode);
+
 
             // called when screen needs to turn off
             void screenReleased();
@@ -286,6 +287,7 @@
         LayerVector     layersSortedByZ;
         uint8_t         orientation;
         uint8_t         orientationFlags;
+        uint32_t        HDMIOutputMode;
     };
 
     virtual bool        threadLoop();
