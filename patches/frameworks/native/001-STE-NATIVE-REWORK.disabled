From c693e6cb41d7ab86ee90e89840a83bfcc64eaac4 Mon Sep 17 00:00:00 2001
From: Meticulus <theonejohnnyd@gmail.com>
Date: Wed, 8 Oct 2014 17:00:27 -0500
Subject: [PATCH] STE NATIVE REWORK

Change-Id: I460afa5751ea82a3150e8d8864df69dfc338d410
---
 include/gui/GLConsumer.h                   |   64 ++++-
 include/media/openmax/OMX_Audio.h          |   29 +++
 include/media/openmax/OMX_IVCommon.h       |    3 +
 include/media/openmax/OMX_Index.h          |    4 +-
 include/ui/FramebufferNativeWindow.h       |   16 ++
 include/ui/PixelFormat.h                   |    9 +
 include/ui/Region.h                        |   26 ++
 libs/gui/GLConsumer.cpp                    |  383 ++++++++++++++++++++++++++++
 libs/ui/Android.mk                         |    4 +
 libs/ui/FramebufferNativeWindow.cpp        |  103 ++++++++
 libs/ui/PixelFormat.cpp                    |   14 +
 opengl/libs/Android.mk                     |    4 +
 opengl/libs/EGL/eglApi.cpp                 |   17 +-
 opengl/libs/EGL/egl_entries.in             |    6 +-
 services/surfaceflinger/Layer.cpp          |   17 +-
 services/surfaceflinger/SurfaceFlinger.cpp |    2 +
 16 files changed, 693 insertions(+), 8 deletions(-)

diff --git a/include/gui/GLConsumer.h b/include/gui/GLConsumer.h
index f08189f..4f15437 100644
--- a/include/gui/GLConsumer.h
+++ b/include/gui/GLConsumer.h
@@ -26,6 +26,10 @@
 
 #include <ui/GraphicBuffer.h>
 
+#ifdef STE_HARDWARE
+#include <hardware/copybit.h>
+#endif
+
 #include <utils/String8.h>
 #include <utils/Vector.h>
 #include <utils/threads.h>
@@ -33,7 +37,9 @@
 namespace android {
 // ----------------------------------------------------------------------------
 
-
+#ifdef STE_HARDWARE
+class IGraphicBufferAlloc;
+#endif
 class String8;
 
 /*
@@ -92,7 +98,11 @@ public:
     // target texture belongs is bound to the calling thread.
     //
     // This calls doGLFenceWait to ensure proper synchronization.
+#ifdef STE_HARDWARE
+    status_t updateTexImage(BufferRejecter* rejecter, bool deferConversion);
+#else
     status_t updateTexImage();
+#endif
 
     // releaseTexImage releases the texture acquired in updateTexImage().
     // This is intended to be used in single buffer mode.
@@ -279,6 +289,13 @@ private:
     // createImage creates a new EGLImage from a GraphicBuffer.
     EGLImageKHR createImage(EGLDisplay dpy,
             const sp<GraphicBuffer>& graphicBuffer, const Rect& crop);
+#ifdef STE_HARDWARE
+    // returns TRUE if buffer needs color format conversion
+    bool conversionIsNeeded(const sp<GraphicBuffer>& graphicBuffer);
+
+    // converts buffer to a suitable color format
+    status_t convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf);
+#endif
 
     // freeBufferLocked frees up the given buffer slot.  If the slot has been
     // initialized this will release the reference to the GraphicBuffer in that
@@ -371,6 +388,12 @@ private:
     // and can be changed with a call to attachToContext.
     uint32_t mTexName;
 
+#ifdef STE_HARDWARE
+    // mGraphicBufferAlloc is the connection to SurfaceFlinger that is used to
+    // allocate new GraphicBuffer objects.
+    sp<IGraphicBufferAlloc> mGraphicBufferAlloc;
+#endif
+
     // mUseFenceSync indicates whether creation of the EGL_KHR_fence_sync
     // extension should be used to prevent buffers from being dequeued before
     // it's safe for them to be written. It gets set at construction time and
@@ -397,6 +420,11 @@ private:
         // mEglImage is the EGLImage created from mGraphicBuffer.
         EGLImageKHR mEglImage;
 
+#ifdef STE_HARDWARE
+        // mEglDisplay is the EGLDisplay used to create mEglImage.
+        EGLDisplay mEglDisplay;
+#endif
+
         // mCropRect is the crop rectangle passed to EGL when mEglImage was
         // created.
         Rect mCropRect;
@@ -451,6 +479,40 @@ private:
     // mReleasedTexImageBuffer is a dummy buffer used when in single buffer
     // mode and releaseTexImage() has been called
     static sp<GraphicBuffer> sReleasedTexImageBuffer;
+
+#ifdef STE_HARDWARE
+    // mBlitEngine is the handle to the copybit device which will be used in
+    // case color transform is needed before the EGL image is created.
+    copybit_device_t* mBlitEngine;
+
+    // mBlitSlots contains several buffers which will
+    // be rendered alternately in case color transform is needed (instead
+    // of rendering the buffers in mSlots).
+    EGLSlot mBlitSlots[NUM_BLIT_BUFFER_SLOTS];
+
+    // mNextBlitSlot is the index of the blitter buffer (in mBlitSlots) which
+    // will be used in the next color transform.
+    int mNextBlitSlot;
+
+    // mConversionSrcSlot designates the slot where source buffer
+    // for the last deferred updateTexImage is located.
+    int mConversionSrcSlot;
+
+    // mConversionBltSlot designates the slot where destination buffer
+    // for the last deferred updateTexImage is located.
+    int mConversionBltSlot;
+
+    // mNeedsConversion indicates that a format conversion is necessary
+    // before the layer based on this surface is drawn.
+    // This flag is set whenever updateTexImage() with deferred conversion
+    // is called. It is cleared once the layer is drawn,
+    // or when updateTexImage() w/o deferred conversion is called.
+    bool mNeedsConversion;
+
+    // mConvertPending indicates that the the object is in a deferred
+    // state and mNeedsConversion is true.
+    bool mConvertPending;
+#endif
 };
 
 // ----------------------------------------------------------------------------
diff --git a/include/media/openmax/OMX_Audio.h b/include/media/openmax/OMX_Audio.h
index 5c66d30..6d8a4b1 100644
--- a/include/media/openmax/OMX_Audio.h
+++ b/include/media/openmax/OMX_Audio.h
@@ -496,6 +496,35 @@ typedef struct OMX_AUDIO_PARAM_WMATYPE {
     OMX_U32 nSuperBlockAlign; /**< WMA Type-specific data */
 } OMX_AUDIO_PARAM_WMATYPE;
 
+#ifdef STE_HARDWARE
+/** WMA Pro Profile */
+typedef enum OMX_AUDIO_WMAPROPROFILETYPE {
+  OMX_AUDIO_WMAPROProfileUnused = 0,          /**< WMA unused / unknown */
+  OMX_AUDIO_WMAPROProfileM0,
+  OMX_AUDIO_WMAPROProfileM1,
+  OMX_AUDIO_WMAPROProfileM2,
+  OMX_AUDIO_WMAPROProfileM3,
+  OMX_AUDIO_WMAPROProfileMax = 0x7FFFFFFF
+} OMX_AUDIO_WMAPROPROFILETYPE;
+
+/** WMA Pro params */
+typedef struct OMX_AUDIO_PARAM_WMAPROTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U16 nChannels;
+    OMX_U32 nBitRate;
+    OMX_AUDIO_WMAPROPROFILETYPE eProfile;
+    OMX_U32 nSamplingRate;
+    OMX_U32 nBlockAlign;
+    OMX_U32 nSuperBlockAlign;
+    OMX_U32 nEncodeOptions;
+    OMX_U32 nAdvancedEncodeOptions;
+    OMX_U32 nAdvancedEncodeOptions2;
+    OMX_U32 nChannelMask;
+    OMX_U32 nSourceBitsPerSample;
+} OMX_AUDIO_PARAM_WMAPROTYPE;
+#endif
 /** 
  * RealAudio format
  */
diff --git a/include/media/openmax/OMX_IVCommon.h b/include/media/openmax/OMX_IVCommon.h
index 96a4396..df49e74 100644
--- a/include/media/openmax/OMX_IVCommon.h
+++ b/include/media/openmax/OMX_IVCommon.h
@@ -159,6 +159,9 @@ typedef enum OMX_COLOR_FORMATTYPE {
     OMX_COLOR_FormatAndroidOpaque = 0x7F000789,
     OMX_TI_COLOR_FormatYUV420PackedSemiPlanar = 0x7F000100,
     OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00,
+#ifdef STE_HARDWARE
+    OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB = 0x7FA00000,
+#endif
     OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03,
     OMX_SEC_COLOR_FormatNV12Tiled = 0x7FC00002,
     OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar32m = 0x7FA30C04,
diff --git a/include/media/openmax/OMX_Index.h b/include/media/openmax/OMX_Index.h
index d40f24f..ff0ea2e 100644
--- a/include/media/openmax/OMX_Index.h
+++ b/include/media/openmax/OMX_Index.h
@@ -269,7 +269,9 @@ typedef enum OMX_INDEXTYPE {
     OMX_IndexParamAudioDts,                 /**< reference: OMX_AUDIO_PARAM_DTSTYPE */
     OMX_IndexParamVideoFFmpeg,              /**< reference: OMX_VIDEO_PARAM_FFMPEGTYPE */
     OMX_IndexParamAudioFFmpeg,              /**< reference: OMX_AUDIO_PARAM_FFMPEGTYPE */
-
+#ifdef STE_HARDWARE
+    OMX_IndexParamAudioWMAPro = 0x7F001012,
+#endif
     OMX_IndexMax = 0x7FFFFFFF
 
 } OMX_INDEXTYPE;
diff --git a/include/ui/FramebufferNativeWindow.h b/include/ui/FramebufferNativeWindow.h
index 87f2b91..40982a3 100644
--- a/include/ui/FramebufferNativeWindow.h
+++ b/include/ui/FramebufferNativeWindow.h
@@ -68,8 +68,17 @@ public:
     status_t setUpdateRectangle(const Rect& updateRect);
     status_t compositionComplete();
 
+#ifdef STE_HARDWARE 
+    status_t rotate(unsigned int absoluteDegree);
+    void discardQueuedBuffers(bool on);
+#endif
+
     void dump(String8& result);
 
+#ifdef STE_HARDWARE
+    void UIRotationChange(int uiRotation);
+#endif
+
     // for debugging only
     int getCurrentBufferIndex() const;
 
@@ -82,6 +91,10 @@ private:
     static int query(const ANativeWindow* window, int what, int* value);
     static int perform(ANativeWindow* window, int operation, ...);
 
+#ifdef STE_HARDWARE
+    static int cancelBuffer(ANativeWindow* window, android_native_buffer_t* buffer);
+#endif
+
     static int dequeueBuffer_DEPRECATED(ANativeWindow* window, ANativeWindowBuffer** buffer);
     static int queueBuffer_DEPRECATED(ANativeWindow* window, ANativeWindowBuffer* buffer);
     static int lockBuffer_DEPRECATED(ANativeWindow* window, ANativeWindowBuffer* buffer);
@@ -99,6 +112,9 @@ private:
     int32_t mBufferHead;
     int32_t mCurrentBufferIndex;
     bool mUpdateOnDemand;
+#ifdef STE_HARDWARE
+    int mDiscardQueuedBuffersCnt;
+#endif
 #ifdef SAMSUNG_HDMI_SUPPORT
     SecHdmiClient *mHdmiClient;
 #endif
diff --git a/include/ui/PixelFormat.h b/include/ui/PixelFormat.h
index 79a29bc..21e6b60 100644
--- a/include/ui/PixelFormat.h
+++ b/include/ui/PixelFormat.h
@@ -63,6 +63,15 @@ enum {
     PIXEL_FORMAT_BGRA_8888   = HAL_PIXEL_FORMAT_BGRA_8888,  // 4x8-bit BGRA
     PIXEL_FORMAT_RGBA_5551   = 6,                           // 16-bit ARGB
     PIXEL_FORMAT_RGBA_4444   = 7,                           // 16-bit ARGB
+
+#ifdef STE_HARDWARE
+    // Added Support for YUV42XMBN,
+    // Required for Copybit CC acceleration
+    PIXEL_FORMAT_YCBCR42XMBN = HAL_PIXEL_FORMAT_YCBCR42XMBN,
+    PIXEL_FORMAT_YCbCr_420_SP = HAL_PIXEL_FORMAT_YCbCr_420_SP,
+    PIXEL_FORMAT_YCbCr_420_P = HAL_PIXEL_FORMAT_YCbCr_420_P,
+    PIXEL_FORMAT_YCbCr_422_I = HAL_PIXEL_FORMAT_YCbCr_422_I,
+#endif
 };
 
 typedef int32_t PixelFormat;
diff --git a/include/ui/Region.h b/include/ui/Region.h
index d906dbb..46f6fb2 100644
--- a/include/ui/Region.h
+++ b/include/ui/Region.h
@@ -25,6 +25,10 @@
 #include <ui/Rect.h>
 #include <utils/Flattenable.h>
 
+#ifdef STE_HARDWARE
+#include <hardware/copybit.h>
+#endif
+
 namespace android {
 // ---------------------------------------------------------------------------
 
@@ -210,6 +214,28 @@ Region& Region::operator -= (const Region& rhs) {
 Region& Region::operator += (const Point& pt) {
     return translateSelf(pt.x, pt.y);
 }
+
+#ifdef STE_HARDWARE
+// ---------------------------------------------------------------------
+struct region_iterator : public copybit_region_t {
+    region_iterator(const Region& region)
+        : b(region.begin()), e(region.end()) {
+        this->next = iterate;
+    }
+private:
+    static int iterate(copybit_region_t const * self, copybit_rect_t* rect) {
+        region_iterator const* me = static_cast<region_iterator const*>(self);
+        if (me->b != me->e) {
+            *reinterpret_cast<Rect*>(rect) = *me->b++;
+            return 1;
+        }
+        return 0;
+    }
+    mutable Region::const_iterator b;
+    Region::const_iterator const e;
+};
+#endif
+
 // ---------------------------------------------------------------------------
 }; // namespace android
 
diff --git a/libs/gui/GLConsumer.cpp b/libs/gui/GLConsumer.cpp
index de83a20..510c18e 100644
--- a/libs/gui/GLConsumer.cpp
+++ b/libs/gui/GLConsumer.cpp
@@ -132,6 +132,11 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex,
     mTexTarget(texTarget),
     mEglDisplay(EGL_NO_DISPLAY),
     mEglContext(EGL_NO_CONTEXT),
+#ifdef STE_HARDWARE
+    mNextBlitSlot(0),
+    mNeedsConversion(false),
+    mConvertPending(false),
+#endif
     mCurrentTexture(BufferQueue::INVALID_BUFFER_SLOT),
     mAttached(true)
 {
@@ -140,6 +145,23 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex,
     memcpy(mCurrentTransformMatrix, mtxIdentity,
             sizeof(mCurrentTransformMatrix));
 
+#ifdef STE_HARDWARE
+    sp<ISurfaceComposer> composer(ComposerService::getComposerService());
+    mGraphicBufferAlloc = composer->createGraphicBufferAlloc();
+
+    for (int i = 0; i < NUM_BLIT_BUFFER_SLOTS; i++) {
+        mBlitSlots[i].mEglImage = EGL_NO_IMAGE_KHR;
+        mBlitSlots[i].mEglDisplay = EGL_NO_DISPLAY;
+    }
+
+    hw_module_t const* module;
+    mBlitEngine = 0;
+    if (hw_get_module(COPYBIT_HARDWARE_MODULE_ID, &module) == 0) {
+        copybit_open(module, &mBlitEngine);
+    }
+    ALOGE_IF(!mBlitEngine, "\nCannot open copybit mBlitEngine=%p", mBlitEngine);
+#endif
+
     mConsumer->setConsumerUsageBits(DEFAULT_USAGE_FLAGS);
 #ifdef QCOM_BSP
     mCurrentDirtyRect.clear();
@@ -160,7 +182,247 @@ status_t GLConsumer::setDefaultBufferSize(uint32_t w, uint32_t h)
     return mConsumer->setDefaultBufferSize(w, h);
 }
 
+#ifdef STE_HARDWARE
+status_t SurfaceTexture::updateTexImage(bool deferConversion) {
+    return SurfaceTexture::updateTexImage(NULL, deferConversion); 
+}
+
+status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool deferConversion) {
+    ATRACE_CALL();
+    ALOGV("updateTexImage");
+    Mutex::Autolock lock(mMutex);
+
+    status_t err = NO_ERROR;
+
+    if (mAbandoned) {
+        ALOGE("updateTexImage: SurfaceTexture is abandoned!");
+        return NO_INIT;
+    }
+
+    if (!mAttached) {
+        ALOGE("updateTexImage: SurfaceTexture is not attached to an OpenGL "
+                "ES context");
+        return INVALID_OPERATION;
+    }
+
+    EGLDisplay dpy = eglGetCurrentDisplay();
+    EGLContext ctx = eglGetCurrentContext();
+
+    if ((mEglDisplay != dpy && mEglDisplay != EGL_NO_DISPLAY) ||
+            dpy == EGL_NO_DISPLAY) {
+        ALOGE("updateTexImage: invalid current EGLDisplay");
+        return INVALID_OPERATION;
+    }
+
+    if ((mEglContext != ctx && mEglContext != EGL_NO_CONTEXT) ||
+            ctx == EGL_NO_CONTEXT) {
+        ALOGE("updateTexImage: invalid current EGLContext");
+        return INVALID_OPERATION;
+    }
+
+    mEglDisplay = dpy;
+    mEglContext = ctx;
+
+    BufferQueue::BufferItem item;
+
+    // In asynchronous mode the list is guaranteed to be one buffer
+    // deep, while in synchronous mode we use the oldest buffer.
+    err = mBufferQueue->acquireBuffer(&item);
+    if (err == NO_ERROR) {
+        int buf = item.mBuf;
+        // This buffer was newly allocated, so we need to clean up on our side
+        if (item.mGraphicBuffer != NULL) {
+            mEGLSlots[buf].mGraphicBuffer = 0;
+            if (mEGLSlots[buf].mEglImage != EGL_NO_IMAGE_KHR) {
+                eglDestroyImageKHR(dpy, mEGLSlots[buf].mEglImage);
+                mEGLSlots[buf].mEglImage = EGL_NO_IMAGE_KHR;
+            }
+            mEGLSlots[buf].mGraphicBuffer = item.mGraphicBuffer;
+        }
+
+        // we call the rejecter here, in case the caller has a reason to
+        // not accept this buffer. this is used by SurfaceFlinger to
+        // reject buffers which have the wrong size
+        if (rejecter && rejecter->reject(mEGLSlots[buf].mGraphicBuffer, item)) {
+            mBufferQueue->releaseBuffer(buf, dpy, mEGLSlots[buf].mFence);
+            mEGLSlots[buf].mFence = EGL_NO_SYNC_KHR;
+            glBindTexture(mTexTarget, mTexName);
+            return NO_ERROR;
+        }
+
+        // Update the GL texture object. We may have to do this even when
+        // item.mGraphicBuffer == NULL, if we destroyed the EGLImage when
+        // detaching from a context but the buffer has not been re-allocated.
+        EGLImageKHR image;
+        sp<GraphicBuffer> graphicBuffer;
+        mConvertPending = false;
+        if (conversionIsNeeded(mEGLSlots[buf].mGraphicBuffer)) {
+            mNeedsConversion = deferConversion;
+            // If color conversion is needed we can't use the graphic buffers
+            // located in mSlots for the textures (wrong color format). Instead
+            // color convert it into a buffer in mBlitSlots and use that instead.
+            image = mBlitSlots[mNextBlitSlot].mEglImage;
+
+            // If there exists an image already, make sure that
+            // the dimensions match the current source buffer.
+            // Otherwise, destroy the buffer and let a new one be allocated.
+            if (image != EGL_NO_IMAGE_KHR &&
+                    mEGLSlots[buf].mGraphicBuffer != NULL &&
+                    mBlitSlots[mNextBlitSlot].mGraphicBuffer != NULL) {
+                sp<GraphicBuffer> &srcBuf = mEGLSlots[buf].mGraphicBuffer;
+                sp<GraphicBuffer> &bltBuf =
+                    mBlitSlots[mNextBlitSlot].mGraphicBuffer;
+                if (srcBuf->getWidth() != bltBuf->getWidth() ||
+                        srcBuf->getHeight() != bltBuf->getHeight()) {
+                    eglDestroyImageKHR(mBlitSlots[mNextBlitSlot].mEglDisplay,
+                        image);
+                    mBlitSlots[mNextBlitSlot].mEglImage = EGL_NO_IMAGE_KHR;
+                    mBlitSlots[mNextBlitSlot].mGraphicBuffer = NULL;
+                    image = EGL_NO_IMAGE_KHR;
+                }
+            }
+
+            if (image == EGL_NO_IMAGE_KHR) {
+                sp<GraphicBuffer> &srcBuf = mEGLSlots[buf].mGraphicBuffer;
+                status_t res = 0;
+
+                sp<GraphicBuffer> blitBuffer(
+                        mGraphicBufferAlloc->createGraphicBuffer(
+                                srcBuf->getWidth(), srcBuf->getHeight(),
+                                PIXEL_FORMAT_RGBA_8888, srcBuf->getUsage(),
+                                &res));
+                if (blitBuffer == 0) {
+                    ALOGE("updateTexImage: SurfaceComposer::createGraphicBuffer failed");
+                    return NO_MEMORY;
+                }
+                if (res != NO_ERROR) {
+                    ALOGW("updateTexImage: SurfaceComposer::createGraphicBuffer error=%#04x", res);
+                }
+                mBlitSlots[mNextBlitSlot].mGraphicBuffer = blitBuffer;
+
+                image = createImage(dpy, blitBuffer);
+                mBlitSlots[mNextBlitSlot].mEglImage = image;
+                mBlitSlots[mNextBlitSlot].mEglDisplay = dpy;
+            }
+
+            if (deferConversion) {
+                mConversionSrcSlot = buf;
+                mConversionBltSlot = mNextBlitSlot;
+                graphicBuffer = mEGLSlots[buf].mGraphicBuffer;
+                mConvertPending = true;
+                // At this point graphicBuffer and image do not point
+                // at matching buffers. This is intentional as this
+                // surface might end up being taken care of by HWComposer,
+                // which needs access to the original buffer.
+                // GL however, is fed an EGLImage that is created from
+                // a conversion buffer. It will have its
+                // content updated once the surface is actually drawn
+                // in Layer::onDraw()
+            } else {
+                if (convert(mEGLSlots[buf].mGraphicBuffer,
+                        mBlitSlots[mNextBlitSlot].mGraphicBuffer) != OK) {
+                    ALOGE("updateTexImage: convert failed");
+                    return UNKNOWN_ERROR;
+                }
+                graphicBuffer = mBlitSlots[mNextBlitSlot].mGraphicBuffer;
+            }
+
+            // mBlitSlots contains several buffers (NUM_BLIT_BUFFER_SLOTS),
+            // advance (potentially wrap) the index
+            mNextBlitSlot = (mNextBlitSlot + 1) % NUM_BLIT_BUFFER_SLOTS;
+        } else {
+            mNeedsConversion = false;
+            image = mEGLSlots[buf].mEglImage;
+            graphicBuffer = mEGLSlots[buf].mGraphicBuffer;
+            if (image == EGL_NO_IMAGE_KHR) {
+                if (graphicBuffer == 0) {
+                    ALOGE("updateTexImage: buffer at slot %d is null", buf);
+                    err = BAD_VALUE;
+                } else {
+                    image = createImage(dpy, graphicBuffer);
+                    mEGLSlots[buf].mEglImage = image;
+                    mEGLSlots[buf].mEglDisplay = dpy;
+                    if (image == EGL_NO_IMAGE_KHR) {
+                        // NOTE: if dpy was invalid, createImage() is guaranteed to
+                        // fail. so we'd end up here.
+                        err = UNKNOWN_ERROR;
+                    }
+                }
+            }
+        }
+
+        if (err == NO_ERROR) {
+            GLint error;
+            while ((error = glGetError()) != GL_NO_ERROR) {
+                ALOGW("updateTexImage: clearing GL error: %#04x", error);
+            }
+
+            glBindTexture(mTexTarget, mTexName);
+            glEGLImageTargetTexture2DOES(mTexTarget, (GLeglImageOES)image);
+
+            while ((error = glGetError()) != GL_NO_ERROR) {
+                ALOGE("updateTexImage: error binding external texture image %p "
+                        "(slot %d): %#04x", image, buf, error);
+                err = UNKNOWN_ERROR;
+            }
+
+            if (err == NO_ERROR) {
+                err = syncForReleaseLocked(dpy);
+            }
+        }
+
+        if (err != NO_ERROR) {
+            // Release the buffer we just acquired.  It's not safe to
+            // release the old buffer, so instead we just drop the new frame.
+            mBufferQueue->releaseBuffer(buf, dpy, mEGLSlots[buf].mFence);
+            mEGLSlots[buf].mFence = EGL_NO_SYNC_KHR;
+            return err;
+        }
+
+        ST_LOGV("updateTexImage: (slot=%d buf=%p) -> (slot=%d buf=%p)",
+                mCurrentTexture,
+                mCurrentTextureBuf != NULL ? mCurrentTextureBuf->handle : 0,
+                buf, item.mGraphicBuffer != NULL ? item.mGraphicBuffer->handle : 0);
+
+        // release old buffer
+        if (mCurrentTexture != BufferQueue::INVALID_BUFFER_SLOT) {
+            status_t status = mBufferQueue->releaseBuffer(mCurrentTexture, dpy,
+                    mEGLSlots[mCurrentTexture].mFence);
+
+            mEGLSlots[mCurrentTexture].mFence = EGL_NO_SYNC_KHR;
+            if (status == BufferQueue::STALE_BUFFER_SLOT) {
+                freeBufferLocked(mCurrentTexture);
+            } else if (status != NO_ERROR) {
+                ALOGE("updateTexImage: released invalid buffer");
+                err = status;
+            }
+        }
+
+        // Update the SurfaceTexture state.
+        mCurrentTexture = buf;
+        mCurrentTextureBuf = graphicBuffer;
+        mCurrentCrop = item.mCrop;
+        mCurrentTransform = item.mTransform;
+        mCurrentScalingMode = item.mScalingMode;
+        mCurrentTimestamp = item.mTimestamp;
+        computeCurrentTransformMatrix();
+    } else  {
+        if (err < 0) {
+            ALOGE("updateTexImage failed on acquire %d", err);
+        }
+        // We always bind the texture even if we don't update its contents.
+        glBindTexture(mTexTarget, mTexName);
+        return OK;
+    }
+
+    return err;
+}
+#endif
+
 status_t GLConsumer::updateTexImage() {
+#ifdef STE_HARDWARE
+return SurfaceTexture::updateTexImage(NULL, false);
+#else
     ATRACE_CALL();
     ST_LOGV("updateTexImage");
     Mutex::Autolock lock(mMutex);
@@ -205,6 +467,7 @@ status_t GLConsumer::updateTexImage() {
 
     // Bind the new buffer to the GL texture, and wait until it's ready.
     return bindTextureImageLocked();
+#endif
 }
 
 
@@ -730,6 +993,13 @@ bool GLConsumer::isExternalFormat(uint32_t format)
     case HAL_PIXEL_FORMAT_YCbCr_422_SP:
     case HAL_PIXEL_FORMAT_YCrCb_420_SP:
     case HAL_PIXEL_FORMAT_YCbCr_422_I:
+#ifdef STE_HARDWARE
+    case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+    case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+    case HAL_PIXEL_FORMAT_YCrCb_422_P:
+    case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+    case HAL_PIXEL_FORMAT_YCrCb_420_P:
+#endif
         return true;
     }
 
@@ -1042,6 +1312,14 @@ Rect GLConsumer::getCurrentDirtyRect() const {
 
 void GLConsumer::freeBufferLocked(int slotIndex) {
     ST_LOGV("freeBufferLocked: slotIndex=%d", slotIndex);
+
+#ifdef STE_HARDWARE
+    // Check is we have a pending conversion before free.
+    if (mConvertPending) {
+        convert();
+    }
+#endif
+
     if (slotIndex == mCurrentTexture) {
         mCurrentTexture = BufferQueue::INVALID_BUFFER_SLOT;
     }
@@ -1052,8 +1330,102 @@ void GLConsumer::freeBufferLocked(int slotIndex) {
     }
     mEglSlots[slotIndex].mEglImage = EGL_NO_IMAGE_KHR;
     ConsumerBase::freeBufferLocked(slotIndex);
+
+#ifdef STE_HARDWARE
+    for (int i = 0; i < NUM_BLIT_BUFFER_SLOTS; i++) {
+         mBlitSlots[i].mGraphicBuffer = 0;
+         if (mBlitSlots[i].mEglImage != EGL_NO_IMAGE_KHR) {
+             eglDestroyImageKHR(mBlitSlots[i].mEglDisplay, mBlitSlots[i].mEglImage);
+             mBlitSlots[i].mEglImage = EGL_NO_IMAGE_KHR;
+             mBlitSlots[i].mEglDisplay = EGL_NO_DISPLAY;
+         }
+     }
+#endif
+
 }
 
+#ifdef STE_HARDWARE
+bool GLConsumer::conversionIsNeeded(const sp<GraphicBuffer>& graphicBuffer) {
+    int fmt = graphicBuffer->getPixelFormat();
+    return (fmt == PIXEL_FORMAT_YCBCR42XMBN)
+            || (fmt == PIXEL_FORMAT_YCbCr_420_P)
+            || (fmt == PIXEL_FORMAT_YCbCr_420_SP)
+            || (fmt == PIXEL_FORMAT_YCbCr_422_I);
+}
+
+status_t GLConsumer::convert() {
+    if (!mNeedsConversion)
+        return NO_ERROR;
+
+    if (mConversionBltSlot < 0 ||
+            mConversionBltSlot >= NUM_BLIT_BUFFER_SLOTS ||
+            mConversionSrcSlot < 0 ||
+            mConversionSrcSlot >= BufferQueue::NUM_BUFFER_SLOTS) {
+        ALOGE_IF(STE_DEFERDBG, "%s: Incorrect setup for deferred "
+            "texture conversion:\n"
+            "mConversionSrcSlot=%d mConversionBltSlot=%d", __FUNCTION__,
+            mConversionSrcSlot, mConversionBltSlot);
+        return BAD_VALUE;
+    }
+
+    if (mEGLSlots[mConversionSrcSlot].mGraphicBuffer == NULL) {
+        ALOGI_IF(STE_DEFERDBG, "%s: NULL source for deferred texture conversion.",
+            __FUNCTION__);
+        return OK;
+    }
+
+    if (mBlitSlots[mConversionBltSlot].mGraphicBuffer == NULL) {
+        ALOGI_IF(STE_DEFERDBG, "%s: NULL destination for deferred "
+            "texture conversion.", __FUNCTION__);
+        return OK;
+    }
+    mConvertPending = false;
+    return convert(mEGLSlots[mConversionSrcSlot].mGraphicBuffer,
+        mBlitSlots[mConversionBltSlot].mGraphicBuffer);
+}
+
+status_t GLConsumer::convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf) {
+    copybit_image_t dstImg;
+    dstImg.w = dstBuf->getWidth();
+    dstImg.h = dstBuf->getHeight();
+    dstImg.format = dstBuf->getPixelFormat();
+    dstImg.handle = (native_handle_t*) dstBuf->getNativeBuffer()->handle;
+
+    copybit_image_t srcImg;
+    srcImg.w = srcBuf->getWidth();
+    srcImg.h = srcBuf->getHeight();
+    srcImg.format = srcBuf->getPixelFormat();
+    srcImg.base = NULL;
+    srcImg.handle = (native_handle_t*) srcBuf->getNativeBuffer()->handle;
+
+    copybit_rect_t dstCrop;
+    dstCrop.l = 0;
+    dstCrop.t = 0;
+    dstCrop.r = dstBuf->getWidth();
+    dstCrop.b = dstBuf->getHeight();
+
+    copybit_rect_t srcCrop;
+    srcCrop.l = 0;
+    srcCrop.t = 0;
+    srcCrop.r = srcBuf->getWidth();
+    srcCrop.b = srcBuf->getHeight();
+
+    region_iterator clip(Region(Rect(dstCrop.r, dstCrop.b)));
+    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_TRANSFORM, 0);
+    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_PLANE_ALPHA, 0xFF);
+    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_DITHER, COPYBIT_ENABLE);
+
+    int err = mBlitEngine->stretch(
+            mBlitEngine, &dstImg, &srcImg, &dstCrop, &srcCrop, &clip);
+    if (err != 0) {
+        ALOGE("\nError: Blit stretch operation failed (err:%d)\n", err);
+        return UNKNOWN_ERROR;
+    }
+    return OK;
+}
+
+#endif
+
 void GLConsumer::abandonLocked() {
     ST_LOGV("abandonLocked");
     mCurrentTextureBuf.clear();
@@ -1094,6 +1466,17 @@ void GLConsumer::dumpLocked(String8& result, const char* prefix) const
     ConsumerBase::dumpLocked(result, prefix);
 }
 
+#ifdef STE_HARDWARE
+GLConsumer::~GLConsumer() {
+    ST_LOGV("~GLConsumer");
+
+    if (mBlitEngine) {
+        copybit_close(mBlitEngine);
+    }
+}
+#endif
+
+
 static void mtxMul(float out[16], const float a[16], const float b[16]) {
     out[0] = a[0]*b[0] + a[4]*b[1] + a[8]*b[2] + a[12]*b[3];
     out[1] = a[1]*b[0] + a[5]*b[1] + a[9]*b[2] + a[13]*b[3];
diff --git a/libs/ui/Android.mk b/libs/ui/Android.mk
index 6c2dcd9..0ca1767 100644
--- a/libs/ui/Android.mk
+++ b/libs/ui/Android.mk
@@ -37,6 +37,10 @@ ifneq ($(BOARD_FRAMEBUFFER_FORCE_FORMAT),)
 LOCAL_CFLAGS += -DFRAMEBUFFER_FORCE_FORMAT=$(BOARD_FRAMEBUFFER_FORCE_FORMAT)
 endif
 
+ifdef BOARD_NUM_FRAME_BUFFERS
+LOCAL_CFLAGS:= -DNUM_FRAME_BUFFERS=$(BOARD_NUM_FRAME_BUFFERS)
+endif
+
 ifeq ($(TARGET_SOC),exynos4210)
     LOCAL_CFLAGS += -DSAMSUNG_EXYNOS4210
 endif
diff --git a/libs/ui/FramebufferNativeWindow.cpp b/libs/ui/FramebufferNativeWindow.cpp
index 12c77b8..a5937b2 100644
--- a/libs/ui/FramebufferNativeWindow.cpp
+++ b/libs/ui/FramebufferNativeWindow.cpp
@@ -72,8 +72,13 @@ private:
  * 
  */
 
+#ifdef STE_HARDWARE
+FramebufferNativeWindow::FramebufferNativeWindow()
+    : BASE(), fbDev(0), grDev(0), mUpdateOnDemand(false), mDiscardQueuedBuffersCnt(0)
+#else
 FramebufferNativeWindow::FramebufferNativeWindow() 
     : BASE(), fbDev(0), grDev(0), mUpdateOnDemand(false)
+#endif
 {
     hw_module_t const* module;
 
@@ -160,6 +165,10 @@ FramebufferNativeWindow::FramebufferNativeWindow()
     ANativeWindow::query = query;
     ANativeWindow::perform = perform;
 
+#ifdef STE_HARDWARE
+    ANativeWindow::cancelBuffer = cancelBuffer;
+#endif
+
     ANativeWindow::dequeueBuffer_DEPRECATED = dequeueBuffer_DEPRECATED;
     ANativeWindow::lockBuffer_DEPRECATED = lockBuffer_DEPRECATED;
     ANativeWindow::queueBuffer_DEPRECATED = queueBuffer_DEPRECATED;
@@ -181,6 +190,52 @@ FramebufferNativeWindow::~FramebufferNativeWindow()
     }
 }
 
+#ifdef STE_HARDWARE
+void FramebufferNativeWindow::UIRotationChange(int uiRotation)
+{
+    if (fbDev->UIRotationChange)
+        fbDev->UIRotationChange(fbDev, uiRotation);
+}
+
+void FramebufferNativeWindow::enableHDMIMirroring(bool enable)
+{
+    if (fbDev->enableHDMIMirroring)
+        fbDev->enableHDMIMirroring(fbDev, enable);
+}
+
+status_t FramebufferNativeWindow::rotate(unsigned int absoluteDegree)
+{
+    Mutex::Autolock _l(mutex);
+    int ret;
+
+    if (fbDev->rotate == NULL)
+        return INVALID_OPERATION;
+
+    ret = fbDev->rotate(fbDev, absoluteDegree);
+    if (ret < 0)
+        /*
+         * Android's error codes seem to match errno, at least the
+         * important stuff.
+         */
+        return ret;
+
+    const_cast<float&>(xdpi) = fbDev->xdpi;
+    const_cast<float&>(ydpi) = fbDev->ydpi;
+
+    return NO_ERROR;
+}
+
+void FramebufferNativeWindow::discardQueuedBuffers(bool on)
+{
+    Mutex::Autolock _l(mutex);
+
+    if (on)
+        mDiscardQueuedBuffersCnt++;
+    else
+        mDiscardQueuedBuffersCnt--;
+}
+#endif
+
 status_t FramebufferNativeWindow::setUpdateRectangle(const Rect& r) 
 {
     if (!mUpdateOnDemand) {
@@ -257,6 +312,11 @@ int FramebufferNativeWindow::dequeueBuffer(ANativeWindow* window,
     // get this buffer
     self->mNumFreeBuffers--;
     self->mCurrentBufferIndex = index;
+#ifdef STE_HARDWARE
+    self->buffers[index]->width = fb->width;
+    self->buffers[index]->height = fb->height;
+    self->buffers[index]->stride = fb->stride;
+#endif
 
     *buffer = self->buffers[index].get();
     *fenceFd = -1;
@@ -282,6 +342,26 @@ int FramebufferNativeWindow::queueBuffer(ANativeWindow* window,
     FramebufferNativeWindow* self = getSelf(window);
     Mutex::Autolock _l(self->mutex);
     framebuffer_device_t* fb = self->fbDev;
+#ifdef STE_HARDWARE
+    NativeBuffer* handle = static_cast<NativeBuffer*>(buffer);
+
+    int res = 0;
+    if (self->mDiscardQueuedBuffersCnt > 0) {
+       /*
+         * Not perfect but in line with how the problem is handled
+         * for app wins which is the most important thing as EGL
+         * implementations make no difference between the FB win
+         * and app wins.
+         */
+        /* Essentially self->mBufferHead-- */
+        self->mBufferHead = (self->mBufferHead + self->mNumBuffers - 1) %
+                self->mNumBuffers;
+    } else {
+        const int index = self->mCurrentBufferIndex;
+        res = fb->post(fb, handle->handle);
+        self->front = handle;
+    }
+#else
     buffer_handle_t handle = static_cast<NativeBuffer*>(buffer)->handle;
 
     sp<Fence> fence(new Fence(fenceFd));
@@ -290,6 +370,7 @@ int FramebufferNativeWindow::queueBuffer(ANativeWindow* window,
     const int index = self->mCurrentBufferIndex;
     int res = fb->post(fb, handle);
     self->front = static_cast<NativeBuffer*>(buffer);
+#endif
     self->mNumFreeBuffers++;
     self->mCondition.broadcast();
 #ifdef SAMSUNG_HDMI_SUPPORT
@@ -377,6 +458,28 @@ int FramebufferNativeWindow::perform(ANativeWindow* window,
     return NAME_NOT_FOUND;
 }
 
+#ifdef STE_HARDWARE
+int FramebufferNativeWindow::cancelBuffer(ANativeWindow* window,
+        android_native_buffer_t* buffer)
+{
+    FramebufferNativeWindow* self = getSelf(window);
+    Mutex::Autolock _l(self->mutex);
+
+    /*
+     * Not perfect but in line with how the problem is handled
+     * for app wins which is the most important thing as EGL
+     * implementations make no difference between the fb window
+     * and app windows.
+     */
+    /* Essentially self->mBufferHead-- */
+    self->mBufferHead = (self->mBufferHead + self->mNumBuffers - 1) %
+        self->mNumBuffers;
+    self->mNumFreeBuffers++;
+    self->mCondition.broadcast();
+
+    return NO_ERROR;
+}
+#endif
 // ----------------------------------------------------------------------------
 }; // namespace android
 // ----------------------------------------------------------------------------
diff --git a/libs/ui/PixelFormat.cpp b/libs/ui/PixelFormat.cpp
index 6517c8c..228aa3b 100644
--- a/libs/ui/PixelFormat.cpp
+++ b/libs/ui/PixelFormat.cpp
@@ -88,10 +88,24 @@ status_t getPixelFormatInfo(PixelFormat format, PixelFormatInfo* info)
     switch (format) {
     case HAL_PIXEL_FORMAT_YCbCr_422_SP:
     case HAL_PIXEL_FORMAT_YCbCr_422_I:
+#ifdef STE_HARDWARE
+    case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+    case HAL_PIXEL_FORMAT_YCbCr_422_P:
+    case HAL_PIXEL_FORMAT_CbYCrY_422_I:
+#endif
         info->bitsPerPixel = 16;
         goto done;
     case HAL_PIXEL_FORMAT_YCrCb_420_SP:
     case HAL_PIXEL_FORMAT_YV12:
+#ifdef STE_HARDWARE
+    case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+    case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED:
+    case HAL_PIXEL_FORMAT_YCrCb_420_SP_TILED:
+    case HAL_PIXEL_FORMAT_YCbCr_420_P:
+    case HAL_PIXEL_FORMAT_YCbCr_420_I:
+    case HAL_PIXEL_FORMAT_CbYCrY_420_I:
+    case HAL_PIXEL_FORMAT_YCBCR42XMBN:
+#endif
         info->bitsPerPixel = 12;
      done:
         info->format = format;
diff --git a/opengl/libs/Android.mk b/opengl/libs/Android.mk
index d04a4a3..8b8751d 100644
--- a/opengl/libs/Android.mk
+++ b/opengl/libs/Android.mk
@@ -70,6 +70,10 @@ ifneq ($(MAX_EGL_CACHE_SIZE),)
   LOCAL_CFLAGS += -DMAX_EGL_CACHE_SIZE=$(MAX_EGL_CACHE_SIZE)
 endif
 
+ifeq ($(ENABLE_FEATURE_FORCE_CLEAR), true)
+	LOCAL_CFLAGS += -DHAS_FORCE_CLEAR
+endif
+
 ifeq ($(BOARD_USE_BGRA_8888),true)
   LOCAL_CFLAGS += -DUSE_BGRA_8888=1
 endif
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index a9dc7b3..a4e1d59 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -139,11 +139,13 @@ static const extention_map_t sExtensionMap[] = {
     { "eglGetSyncAttribKHR",
             (__eglMustCastToProperFunctionPointerType)&eglGetSyncAttribKHR },
 
+#ifndef STE_HARDWARE
     // EGL_NV_system_time
     { "eglGetSystemTimeFrequencyNV",
             (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
     { "eglGetSystemTimeNV",
             (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
+#endif
 
     // EGL_KHR_wait_sync
     { "eglWaitSyncKHR",
@@ -1106,6 +1108,18 @@ EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface draw)
         }
     }
 
+#ifdef HAS_FORCE_CLEAR
+    //We clear the next frame before giving it to the application.
+    GLboolean hasScissorTest = GL_FALSE;
+    s->cnx->hooks[egl_connection_t::GLESv1_INDEX]->gl.glGetBooleanv(GL_SCISSOR_TEST,
+                                                                    &hasScissorTest);
+    if (hasScissorTest)
+        s->cnx->hooks[egl_connection_t::GLESv1_INDEX]->gl.glDisable(GL_SCISSOR_TEST);
+    s->cnx->hooks[egl_connection_t::GLESv1_INDEX]->gl.glClear(GL_COLOR_BUFFER_BIT);
+    if (hasScissorTest)
+        s->cnx->hooks[egl_connection_t::GLESv1_INDEX]->gl.glEnable(GL_SCISSOR_TEST);
+#endif
+
     return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
 }
 
@@ -1599,6 +1613,7 @@ EGLBoolean eglGpuPerfHintQCOM(EGLDisplay dpy, EGLContext ctx, EGLint *attrib_lis
 // ----------------------------------------------------------------------------
 // NVIDIA extensions
 // ----------------------------------------------------------------------------
+#ifndef STE_HARDWARE
 EGLuint64NV eglGetSystemTimeFrequencyNV()
 {
     clearError();
@@ -1616,7 +1631,7 @@ EGLuint64NV eglGetSystemTimeFrequencyNV()
 
     return setErrorQuiet(EGL_BAD_DISPLAY, 0);
 }
-
+#endif
 EGLuint64NV eglGetSystemTimeNV()
 {
     clearError();
diff --git a/opengl/libs/EGL/egl_entries.in b/opengl/libs/EGL/egl_entries.in
index aa92ea0..52af354 100644
--- a/opengl/libs/EGL/egl_entries.in
+++ b/opengl/libs/EGL/egl_entries.in
@@ -86,11 +86,11 @@ EGL_ENTRY(EGLint, eglDupNativeFenceFDANDROID, EGLDisplay, EGLSyncKHR)
 EGL_ENTRY(EGLBoolean, eglGpuPerfHintQCOM, EGLDisplay, EGLContext, EGLint *)
 
 /* NVIDIA extensions */
-
+/*
 EGL_ENTRY(EGLuint64NV, eglGetSystemTimeFrequencyNV, void)
 EGL_ENTRY(EGLuint64NV, eglGetSystemTimeNV, void)
-
+*/
 /* IMG extensions */
 
 EGL_ENTRY(EGLBoolean, eglHibernateProcessIMG, void)
-EGL_ENTRY(EGLBoolean, eglAwakenProcessIMG, void)
\ No newline at end of file
+EGL_ENTRY(EGLBoolean, eglAwakenProcessIMG, void)
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index d971093..49b0114 100644
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -553,7 +553,17 @@ void Layer::draw(const sp<const DisplayDevice>& hw) {
 void Layer::onDraw(const sp<const DisplayDevice>& hw, const Region& clip) const
 {
     ATRACE_CALL();
-
+#ifdef STE_HARDWARE
+    // Convert the texture to a native format if need be.
+    // convert() returns immediately if no conversion is necessary.
+    if (mSurfaceFlingerConsumer != NULL) {
+        status_t res = mSurfaceFlingerConsumer->convert();
+        if (res != NO_ERROR) {
+            ALOGE("Layer::onDraw: texture conversion failed. "
+                "Texture content for this layer will not be initialized.");
+        }
+    }
+#endif
     if (CC_UNLIKELY(mActiveBuffer == 0)) {
         // the texture has not been created yet, this Layer has
         // in fact never been drawn into. This happens frequently with
@@ -1178,9 +1188,12 @@ Region Layer::latchBuffer(bool& recomputeVisibleRegions)
 
 
         Reject r(mDrawingState, getCurrentState(), recomputeVisibleRegions);
-
+#ifdef STE_HARDWARE
+	if (mSurfaceFlingerConsumer->updateTexImage(&r, true) < NO_ERROR) {
+#else
         status_t updateResult = mSurfaceFlingerConsumer->updateTexImage(&r);
         if (updateResult == BufferQueue::PRESENT_LATER) {
+#endif
             // Producer doesn't want buffer to be displayed yet.  Signal a
             // layer update so we check again at the next opportunity.
             mFlinger->signalLayerUpdate();
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index e7c4716..7612958 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -991,7 +991,9 @@ void SurfaceFlinger::doDebugFlashRegions()
                 // and draw the dirty region
                 engine.fillRegionWithColor(dirtyRegion, height, 1, 0, 1, 1);
                 engine.endTileComposition(GL_PRESERVE);
+#ifndef STE_HARDWARE
                 hw->compositionComplete();
+#endif
                 hw->swapBuffers(getHwComposer());
             } else
 #endif
-- 
1.7.9.5

